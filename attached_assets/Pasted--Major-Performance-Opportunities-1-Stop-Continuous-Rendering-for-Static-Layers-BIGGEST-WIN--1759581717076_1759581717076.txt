üéØ Major Performance Opportunities
1. Stop Continuous Rendering for Static Layers ‚ö° (BIGGEST WIN)
Current issue: Both Canvas and Three.js render 60fps continuously, even for static layers (spinSpeed=0)

Optimization:

// Separate layers into static vs animated
const staticLayers = layers.filter(l => !l.processors.length || l.spinSpeed === 0);
const animatedLayers = layers.filter(l => l.processors.length > 0 && l.spinSpeed !== 0);
// Render static layers ONCE
renderStatic(staticLayers);
// Only animate the animated layers
if (animatedLayers.length > 0) {
  animate(animatedLayers);
} else {
  // No animation needed - save CPU/battery
  console.log('[Engine] No animated layers - skipping animation loop');
}
Impact:

Saves ~95% CPU for static scenes
Battery life improvement on mobile
Same visual output
2. Cache Processor Results for Static Layers üíæ
Current issue: runPipeline() executes every frame even when spinSpeed=0

Optimization:

// In LayerEngine - cache static layer data
const staticLayerCache = new Map();
for (const layer of layers) {
  if (layer.processors.length === 0 || layer.spinSpeed === 0) {
    // Calculate once, reuse forever
    const staticData = runPipeline(layer.baseData, layer.processors, 0);
    staticLayerCache.set(layer.baseData.layerId, staticData);
  }
}
// In render loop
const layerData = staticLayerCache.has(layerId)
  ? staticLayerCache.get(layerId)  // No calculation
  : runPipeline(baseData, processors, timestamp);  // Calculate
Impact:

Eliminates redundant calculations
Reduces garbage collection
Same output
3. Pre-calculate Transform Constants üßÆ
Current issue: These calculations happen every frame in animation loop:

// Every frame:
const centerX = (image.width / 2) * layerData.scale.x;
const centerY = (image.height / 2) * layerData.scale.y;
const pivotX = pivot.x * layerData.scale.x;
const pivotY = pivot.y * layerData.scale.y;
const dx = centerX - pivotX;
const dy = centerY - pivotY;
Optimization: Calculate once during setup:

type LayerRenderData = {
  image: HTMLImageElement;
  baseData: EnhancedLayerData;
  processors: LayerProcessor[];
  // NEW: Pre-calculated constants
  transformCache: {
    scaledWidth: number;
    scaledHeight: number;
    centerX: number;
    centerY: number;
    pivotOffset: { x: number; y: number };  // Pre-calculated dx, dy
  };
};
// Calculate once during mount
const transformCache = {
  scaledWidth: image.width * data.scale.x,
  scaledHeight: image.height * data.scale.y,
  centerX: (image.width / 2) * data.scale.x,
  centerY: (image.height / 2) * data.scale.y,
  pivotOffset: {
    x: centerX - (pivot.x * data.scale.x),
    y: centerY - (pivot.y * data.scale.y),
  }
};
Impact:

5-6 multiplications eliminated per layer per frame
For 4 layers at 60fps: ~1440 calculations/sec ‚Üí 0
Same visual result
4. Remove Redundant Conditional Checks üîç
Current issue: Every frame checks:

const isSpinning = layerData.hasSpinAnimation === true;
const rotation = isSpinning ? ... : ...;
const pivot = isSpinning ? ... : ...;
if (rotation !== 0) { ... }
Optimization: Split layers by type during setup:

const rotatingLayers = [];    // Has rotation > 0
const staticLayers = [];       // No rotation
// Render with specialized functions (no conditionals)
renderStaticLayers(staticLayers);   // Always use fast path
renderRotatingLayers(rotatingLayers); // Always use rotation path
Impact:

Branch prediction improvements
Cleaner code
Same output
5. Optimize Spin Processor for Static Case ‚öôÔ∏è
Current issue: Spin processor creates new object even when spinSpeed=0:

if (spinSpeed === 0) {
  return {
    ...layer,  // Spread creates new object
    hasSpinAnimation: false,
  };
}
Optimization:

if (spinSpeed === 0) {
  return layer;  // Return original - no allocation
}
Impact:

Eliminates object creation for static layers
Reduces memory pressure
Identical behavior
6. Batch Canvas Operations üé®
Current Canvas code does save/restore per layer:

for (const layer of layers) {
  ctx.save();
  // ... render layer
  ctx.restore();
}
Optimization: Only save/restore when needed:

for (const layer of layers) {
  if (layer.hasRotation) {
    ctx.save();
    // ... rotation transforms
    ctx.restore();
  } else {
    // Direct draw - no state changes
    ctx.drawImage(image, x, y, width, height);
  }
}
Impact:

Reduces Canvas state management overhead
Same visual output
7. Use Three.js Render-on-Demand for Mixed Scenes üéÆ
Current: Continuous rendering even with only 1 spinning layer

Optimization:

let needsRender = false;
let lastRotation = new Map();
// Only render when rotation actually changes
for (const item of meshData) {
  const newRotation = calculateRotation(item, timestamp);
  const oldRotation = lastRotation.get(item.id);
  
  if (newRotation !== oldRotation) {
    needsRender = true;
    lastRotation.set(item.id, newRotation);
    // Update mesh
  }
}
if (needsRender) {
  renderer.render(scene, camera);
}
Impact:

Skips redundant renders when nothing changed
GPU stays idle when possible
üìä Expected Performance Gains
Scene Type	Current FPS Cost	Optimized FPS Cost	CPU Savings
All static (0 spinning)	60 FPS	0 FPS	~100%
1 spinning layer	60 FPS	60 FPS	~75%*
All spinning	60 FPS	60 FPS	~40%*
*Savings from eliminated calculations, not frame rate

üéØ Quick Wins (Easiest to Implement)
#5 - Return original layer object when spinSpeed=0 (1 line change)
#2 - Cache static layers (10 lines of code)
#3 - Pre-calculate transforms during mount (minimal changes)
These three alone would give ~50% performance improvement for typical scenes.