# Orbital Motion Implementation Plan

## 📋 Document Purpose

Complete end-to-end implementation guide for adding Orbital Motion logic to the Yuzha Animation Framework. This document is written for AI agents to understand and implement the feature.

---

## 🎯 Current System State

### Architecture Overview

The system uses a **Pipeline Pattern** for layer processing:

```
JSON Config → LayerCore (Basic Logic) → Processors → Rendering Engine → Display
```

### Existing Processors

1. **LayerCore.ts** - Basic layer preparation
   - Loads images
   - Calculates position, scale
   - Computes imageMapping (imageCenter, imageTip, imageBase, displayRotation)

2. **LayerCorePipelineSpin.ts** - Spin rotation logic
   - Rotates image around spinCenter
   - Time-based rotation using spinSpeed
   - Already implemented and working

### Current Config Structure

```json
{
  "layerId": "example-layer",
  "groups": {
    "Basic Config": {
      "renderer": "2D",
      "order": 100,
      "imageId": "IMAGE_ID",
      "scale": [100, 100],
      "position": [1024, 1024],
      "imageTip": 90,
      "imageBase": 270
    },
    "Spin Config": {
      "spinCenter": [50, 50],
      "spinSpeed": 10,
      "spinDirection": "cw"
    }
  }
}
```

---

## 🚀 What We're Adding: Orbital Motion

### Feature Description

**Orbital Motion** = Image moves in a circular path around a center point on the stage.

### Key Terminology

| Term                | Definition                                                  | Example                       |
| ------------------- | ----------------------------------------------------------- | ----------------------------- |
| **orbitCenter**     | Fixed center point on stage (2048×2048) where orbit happens | `[1024, 1024]` (stage center) |
| **orbitLine**       | The circular path itself (imaginary circle)                 | Radius = 300 pixels           |
| **orbitRadius**     | Distance from orbitCenter (defines orbitLine radius)        | `300` pixels                  |
| **orbitPoint**      | Calculated position on orbitLine at current time            | Changes each frame            |
| **orbitImagePoint** | Which point on the image is placed at orbitPoint            | `[50, 50]` (image center)     |
| **orbitSpeed**      | How fast image orbits (degrees per second)                  | `10` degrees/sec              |
| **orbitDirection**  | Orbit direction                                             | `"cw"` or `"ccw"`             |

### Visual Concept

```
Stage (2048×2048)

     orbitCenter ● (fixed, e.g., [1024, 1024])
                ╱ ╲
               ╱   ╲ ← orbitRadius = 300px
              ╱     ╲
             ●───────● ← orbitLine (circular path)
             ↑
         orbitPoint (calculated position, changes over time)

Image is positioned so orbitImagePoint is at orbitPoint
```

### How It Works

1. Calculate **orbitPoint** position on stage:

   ```
   orbitPoint.x = orbitCenter.x + orbitRadius × cos(angle)
   orbitPoint.y = orbitCenter.y + orbitRadius × sin(angle)
   ```

2. Convert **orbitImagePoint** from percentage to pixels:

   ```
   orbitImagePointPixels.x = (orbitImagePoint[0] / 100) × imageWidth
   orbitImagePointPixels.y = (orbitImagePoint[1] / 100) × imageHeight
   ```

3. Position image so **orbitImagePoint** is at **orbitPoint**:

   ```
   imagePosition.x = orbitPoint.x - orbitImagePointPixels.x
   imagePosition.y = orbitPoint.y - orbitImagePointPixels.y
   ```

4. **If image is static (no spin)**: Auto-rotate imageTip to point outward from orbitCenter

---

## 📦 New Configuration Structure

### JSON Config with Orbital

```json
{
  "layerId": "orbiting-moon",
  "groups": {
    "Basic Config": {
      "renderer": "2D",
      "order": 100,
      "imageId": "MOON",
      "scale": [100, 100],
      "position": [1024, 1024],
      "imageTip": 90,
      "imageBase": 270
    },
    "Spin Config": {
      "spinCenter": [50, 50],
      "spinSpeed": 5,
      "spinDirection": "cw"
    },
    "Orbital Config": {
      "orbitCenter": [1024, 1024],
      "orbitImagePoint": [50, 50],
      "orbitRadius": 300,
      "orbitSpeed": 10,
      "orbitDirection": "cw"
    }
  }
}
```

### Config Properties Explained

| Property          | Type               | Range  | Default                      | Description                        |
| ----------------- | ------------------ | ------ | ---------------------------- | ---------------------------------- |
| `orbitCenter`     | `[number, number]` | 0-2048 | `[1024, 1024]` (stageCenter) | Center point of orbit on stage     |
| `orbitImagePoint` | `[number, number]` | 0-100  | `[50, 50]` (imageCenter)     | Which point on image follows orbit |
| `orbitRadius`     | `number`           | 0-2048 | Required                     | Radius of circular orbit path      |
| `orbitSpeed`      | `number`           | any    | `0`                          | Degrees per second (0 = no orbit)  |
| `orbitDirection`  | `"cw" \| "ccw"`    | -      | `"cw"`                       | Clockwise or counter-clockwise     |

### Default/Fallback Behavior

```typescript
// If user doesn't specify:
orbitCenter = stageCenter = [1024, 1024];
orbitImagePoint = imageCenter = [50, 50];
orbitSpeed = 0; // No orbital motion
orbitDirection = "cw";
```

---

## 🔄 Interaction with Spin Logic

### Case 1: Image with Both Spin and Orbit

```json
"Spin Config": { "spinSpeed": 5 },
"Orbital Config": { "orbitSpeed": 10 }
```

**Behavior:**

- Image **spins** around its spinCenter (5°/sec)
- Image **orbits** around orbitCenter (10°/sec)
- Both animations happen **simultaneously**
- Like Earth: spins on axis while orbiting the Sun

### Case 2: Static Image with Orbit Only

```json
"Spin Config": { "spinSpeed": 0 },
"Orbital Config": { "orbitSpeed": 10 }
```

**Behavior:**

- Image does NOT spin
- Image orbits around orbitCenter
- **imageTip auto-rotates to point outward** from orbitCenter
- Like clock hand: always points away from center

### Key Point: No Conflict

- **Spin logic** controls image rotation
- **Orbital logic** controls image position
- They work on different properties → independent

---

## 🛠️ Implementation Steps

### Step 1: Create LayerCorePipelineOrbital.ts

**File:** `/app/shared/layer/LayerCorePipelineOrbital.ts`

**Purpose:** Create orbital processor function

**Code Structure:**

```typescript
import type { UniversalLayerData } from "./LayerCore";
import type { EnhancedLayerData, LayerProcessor } from "./LayerCorePipeline";

export type OrbitalConfig = {
  orbitCenter?: [number, number]; // Stage coords (0-2048), default [1024, 1024]
  orbitImagePoint?: [number, number]; // Image coords (0-100%), default [50, 50]
  orbitRadius?: number; // Pixels (0-2048)
  orbitSpeed?: number; // Degrees per second, 0 = no orbit
  orbitDirection?: "cw" | "ccw"; // Default "cw"
};

export function createOrbitalProcessor(config: OrbitalConfig): LayerProcessor {
  // Extract config with defaults
  const STAGE_CENTER = 1024;
  const orbitCenter = config.orbitCenter ?? [STAGE_CENTER, STAGE_CENTER];
  const orbitImagePoint = config.orbitImagePoint ?? [50, 50];
  const orbitRadius = config.orbitRadius ?? 0;
  const orbitSpeed = config.orbitSpeed ?? 0;
  const orbitDirection = config.orbitDirection ?? "cw";

  // If no orbital motion, return passthrough
  if (orbitSpeed === 0 || orbitRadius === 0) {
    return (layer: UniversalLayerData): EnhancedLayerData => layer as EnhancedLayerData;
  }

  // Track start time
  let startTime: number | null = null;

  return (layer: EnhancedLayerData, timestamp?: number): EnhancedLayerData => {
    const currentTime = timestamp ?? performance.now();
    if (startTime === null) {
      startTime = currentTime;
    }

    // Calculate orbital angle
    const elapsed = (currentTime - startTime) / 1000;
    let orbitAngle = (elapsed * orbitSpeed) % 360;
    if (orbitDirection === "ccw") {
      orbitAngle = -orbitAngle;
    }

    // Convert angle to radians
    const orbitAngleRad = (orbitAngle * Math.PI) / 180;

    // Calculate orbitPoint on stage
    const orbitPoint = {
      x: orbitCenter[0] + orbitRadius * Math.cos(orbitAngleRad),
      y: orbitCenter[1] + orbitRadius * Math.sin(orbitAngleRad),
    };

    // Convert orbitImagePoint from percentage to pixels
    const { width, height } = layer.imageMapping.imageDimensions;
    const orbitImagePointPixels = {
      x: (orbitImagePoint[0] / 100) * width,
      y: (orbitImagePoint[1] / 100) * height,
    };

    // Calculate new image position
    const newPosition = {
      x: orbitPoint.x - orbitImagePointPixels.x,
      y: orbitPoint.y - orbitImagePointPixels.y,
    };

    // Handle static image rotation (if no spin)
    let additionalRotation = 0;
    if (!layer.hasSpinAnimation || layer.spinSpeed === 0) {
      // Calculate angle from orbitCenter to orbitPoint (outward direction)
      const dx = orbitPoint.x - orbitCenter[0];
      const dy = orbitPoint.y - orbitCenter[1];
      const outwardAngle = (Math.atan2(dy, dx) * 180) / Math.PI;

      // Rotate so imageTip points in outward direction
      // imageTip default is 90° (pointing up)
      additionalRotation = outwardAngle - 90;
    }

    return {
      ...layer,
      position: newPosition,
      orbitCenter: { x: orbitCenter[0], y: orbitCenter[1] },
      orbitImagePoint: { x: orbitImagePoint[0], y: orbitImagePoint[1] },
      orbitRadius,
      orbitSpeed,
      orbitDirection,
      currentOrbitAngle: orbitAngle,
      orbitRotation: additionalRotation,
      hasOrbitalAnimation: true,
    };
  };
}
```

---

### Step 2: Update EnhancedLayerData Type

**File:** `/app/shared/layer/LayerCorePipeline.ts`

**Add orbital properties to EnhancedLayerData:**

```typescript
export type EnhancedLayerData = UniversalLayerData & {
  // Spin properties
  spinCenter?: { x: number; y: number };
  spinSpeed?: number;
  spinDirection?: "cw" | "ccw";
  currentRotation?: number;
  hasSpinAnimation?: boolean;

  // Orbital properties (NEW)
  orbitCenter?: { x: number; y: number };
  orbitImagePoint?: { x: number; y: number };
  orbitRadius?: number;
  orbitSpeed?: number;
  orbitDirection?: "cw" | "ccw";
  currentOrbitAngle?: number;
  orbitRotation?: number; // Additional rotation for static images
  hasOrbitalAnimation?: boolean;

  // Future properties
  opacity?: number;
  filters?: string[];
};
```

---

### Step 3: Update Config Types

**File:** `/app/shared/config/Config.ts`

**Add to LayerConfigEntry:**

```typescript
export type LayerConfigEntry = {
  layerId: string;
  renderer: LayerRenderer;
  order: number;
  imageId: string;
  scale?: number[];
  position?: number[];

  // Image mapping
  imageTip?: number;
  imageBase?: number;

  // Spin config
  spinCenter?: number[];
  spinSpeed?: number;
  spinDirection?: "cw" | "ccw";

  // Orbital config (NEW)
  orbitCenter?: number[];
  orbitImagePoint?: number[];
  orbitRadius?: number;
  orbitSpeed?: number;
  orbitDirection?: "cw" | "ccw";
};
```

**Add to ConfigYuzhaEntry groups type:**

```typescript
type ConfigYuzhaEntry = {
  layerId: string;
  groups: {
    [groupName: string]: {
      // ... existing properties ...

      // Orbital config (NEW)
      orbitCenter?: number[];
      orbitImagePoint?: number[];
      orbitRadius?: number;
      orbitSpeed?: number;
      orbitDirection?: "cw" | "ccw";
    };
  };
};
```

---

### Step 4: Update ConfigYuzha.json

**File:** `/app/shared/config/ConfigYuzha.json`

**Add example orbital configuration:**

```json
[
  {
    "layerId": "stars-background",
    "groups": {
      "Basic Config": {
        "renderer": "2D",
        "order": 50,
        "imageId": "STARBG",
        "scale": [100, 100],
        "position": [1024, 1024],
        "imageTip": 90,
        "imageBase": 270
      },
      "Spin Config": {
        "spinCenter": [50, 50],
        "spinSpeed": 0,
        "spinDirection": "cw"
      },
      "Orbital Config": {
        "orbitCenter": [1024, 1024],
        "orbitImagePoint": [50, 50],
        "orbitRadius": 0,
        "orbitSpeed": 0,
        "orbitDirection": "cw"
      }
    }
  },
  {
    "layerId": "orbiting-moon",
    "groups": {
      "Basic Config": {
        "renderer": "2D",
        "order": 200,
        "imageId": "GEARMOON",
        "scale": [80, 80],
        "position": [1024, 1024],
        "imageTip": 90,
        "imageBase": 270
      },
      "Spin Config": {
        "spinCenter": [50, 50],
        "spinSpeed": 5,
        "spinDirection": "cw"
      },
      "Orbital Config": {
        "orbitCenter": [1024, 1024],
        "orbitImagePoint": [50, 50],
        "orbitRadius": 400,
        "orbitSpeed": 15,
        "orbitDirection": "cw"
      }
    }
  }
]
```

---

### Step 5: Update StageCanvas.tsx

**File:** `/app/shared/stages/StageCanvas.tsx`

**Add orbital processor to pipeline:**

```typescript
import { createSpinProcessor } from "../layer/LayerCorePipelineSpin";
import { createOrbitalProcessor } from "../layer/LayerCorePipelineOrbital"; // NEW

// ... inside run() function:

for (const entry of twoDLayers) {
  const layer = await prepareLayer(entry, STAGE_SIZE);
  if (!layer) {
    console.warn(`[StageCanvas] Skipping layer ${entry.layerId}`);
    continue;
  }

  const processors: LayerProcessor[] = [];

  // 1. Add spin processor if configured
  if (entry.spinSpeed !== undefined || entry.spinCenter !== undefined) {
    processors.push(
      createSpinProcessor({
        spinCenter: entry.spinCenter as [number, number] | undefined,
        spinSpeed: entry.spinSpeed,
        spinDirection: entry.spinDirection,
      }),
    );
  }

  // 2. Add orbital processor if configured (NEW)
  if (entry.orbitSpeed !== undefined || entry.orbitRadius !== undefined) {
    processors.push(
      createOrbitalProcessor({
        orbitCenter: entry.orbitCenter as [number, number] | undefined,
        orbitImagePoint: entry.orbitImagePoint as [number, number] | undefined,
        orbitRadius: entry.orbitRadius,
        orbitSpeed: entry.orbitSpeed,
        orbitDirection: entry.orbitDirection,
      }),
    );
  }

  layersWithProcessors.push({
    data: layer,
    processors,
  });
}
```

---

### Step 6: Update StageThree.tsx

**File:** `/app/shared/stages/StageThree.tsx`

**Apply same changes as StageCanvas.tsx:**

```typescript
import { createSpinProcessor } from "../layer/LayerCorePipelineSpin";
import { createOrbitalProcessor } from "../layer/LayerCorePipelineOrbital"; // NEW

// Same processor chain as StageCanvas
```

---

### Step 7: Update LayerEngineCanvas.ts

**File:** `/app/shared/layer/LayerEngineCanvas.ts`

**Handle orbital rotation for static images:**

```typescript
const render = (timestamp: number) => {
  ctx.clearRect(0, 0, STAGE_SIZE, STAGE_SIZE);

  for (const layer of layers) {
    const { image, baseData, processors } = layer;

    // Run pipeline
    const layerData: EnhancedLayerData =
      processors.length > 0 ? runPipeline(baseData, processors, timestamp) : baseData;

    const width = image.width * layerData.scale.x;
    const height = image.height * layerData.scale.y;

    ctx.save();

    // Determine rotation
    let rotation = 0;
    let pivot = layerData.imageMapping.imageCenter;

    if (layerData.hasSpinAnimation && layerData.spinSpeed && layerData.spinSpeed > 0) {
      // HAS SPIN: Use spin rotation
      rotation = layerData.currentRotation || 0;
      pivot = layerData.spinCenter || layerData.imageMapping.imageCenter;
    } else if (layerData.hasOrbitalAnimation && layerData.orbitRotation !== undefined) {
      // STATIC with ORBIT: Use orbital rotation (imageTip points outward)
      rotation = layerData.orbitRotation;
      pivot = layerData.imageMapping.imageCenter;
    } else {
      // STATIC: Use display rotation from imageMapping
      rotation = layerData.imageMapping.displayRotation || 0;
      pivot = layerData.imageMapping.imageCenter;
    }

    // Apply rotation around pivot
    if (rotation !== 0) {
      const centerX = (image.width / 2) * layerData.scale.x;
      const centerY = (image.height / 2) * layerData.scale.y;
      const pivotX = pivot.x * layerData.scale.x;
      const pivotY = pivot.y * layerData.scale.y;
      const dx = centerX - pivotX;
      const dy = centerY - pivotY;

      ctx.translate(layerData.position.x, layerData.position.y);
      ctx.translate(-dx, -dy);
      ctx.rotate((rotation * Math.PI) / 180);
      ctx.translate(dx, dy);
      ctx.drawImage(image, -centerX, -centerY, width, height);
    } else {
      const x = layerData.position.x - width / 2;
      const y = layerData.position.y - height / 2;
      ctx.drawImage(image, x, y, width, height);
    }

    ctx.restore();
  }
};
```

---

### Step 8: Update LayerEngineThree.ts

**File:** `/app/shared/layer/LayerEngineThree.ts`

**Apply similar rotation logic as Canvas:**

```typescript
const animate = (timestamp: number) => {
  for (const item of meshData) {
    const { mesh, group, baseData, processors } = item;

    const layerData: EnhancedLayerData =
      processors.length > 0 ? runPipeline(baseData, processors, timestamp) : baseData;

    // Determine rotation
    let rotation = 0;

    if (layerData.hasSpinAnimation && layerData.spinSpeed && layerData.spinSpeed > 0) {
      rotation = layerData.currentRotation || 0;
    } else if (layerData.hasOrbitalAnimation && layerData.orbitRotation !== undefined) {
      rotation = layerData.orbitRotation;
    } else {
      rotation = layerData.imageMapping.displayRotation || 0;
    }

    // Update mesh position and rotation
    group.position.set(layerData.position.x, layerData.position.y, 0);
    mesh.rotation.z = (rotation * Math.PI) / 180;
  }

  renderer.render(scene, camera);
  animationId = requestAnimationFrame(animate);
};
```

---

## 🧪 Testing Plan

### Test Case 1: Static Image with Orbit

**Config:**

```json
"Spin Config": { "spinSpeed": 0 },
"Orbital Config": {
  "orbitRadius": 300,
  "orbitSpeed": 10,
  "orbitDirection": "cw"
}
```

**Expected:**

- ✅ Image orbits around stageCenter
- ✅ imageTip always points outward from center
- ✅ Complete orbit in 36 seconds (360° / 10°/sec)

---

### Test Case 2: Spinning Image with Orbit

**Config:**

```json
"Spin Config": { "spinSpeed": 5 },
"Orbital Config": {
  "orbitRadius": 300,
  "orbitSpeed": 10
}
```

**Expected:**

- ✅ Image spins on its axis (5°/sec)
- ✅ Image orbits around stageCenter (10°/sec)
- ✅ Both animations simultaneous

---

### Test Case 3: Custom orbitImagePoint

**Config:**

```json
"Orbital Config": {
  "orbitImagePoint": [30, 70],
  "orbitRadius": 300,
  "orbitSpeed": 10
}
```

**Expected:**

- ✅ Point at [30%, 70%] of image follows orbit
- ✅ Creates off-center orbital effect

---

### Test Case 4: No Orbital Motion

**Config:**

```json
"Orbital Config": {
  "orbitSpeed": 0
}
```

**Expected:**

- ✅ Image stays at original position
- ✅ No performance impact
- ✅ Works like before orbital feature

---

## 📝 Implementation Checklist

- [ ] Create `/app/shared/layer/LayerCorePipelineOrbital.ts`
- [ ] Update `EnhancedLayerData` type in `/app/shared/layer/LayerCorePipeline.ts`
- [ ] Update `LayerConfigEntry` type in `/app/shared/config/Config.ts`
- [ ] Update `/app/shared/config/ConfigYuzha.json` with examples
- [ ] Update `/app/shared/stages/StageCanvas.tsx` - add orbital processor
- [ ] Update `/app/shared/stages/StageThree.tsx` - add orbital processor
- [ ] Update `/app/shared/layer/LayerEngineCanvas.ts` - rotation logic
- [ ] Update `/app/shared/layer/LayerEngineThree.ts` - rotation logic
- [ ] Test Case 1: Static with orbit
- [ ] Test Case 2: Spin + orbit
- [ ] Test Case 3: Custom orbitImagePoint
- [ ] Test Case 4: No orbit
- [ ] Run `npm run typecheck` - verify no TypeScript errors
- [ ] Run `npm run lint:fix` - fix any lint issues
- [ ] Test in browser - verify visual correctness
- [ ] Performance check - maintain 60fps

---

## 🎯 Key Success Criteria

1. ✅ Image can orbit around any point on stage
2. ✅ Orbit and spin work simultaneously without conflict
3. ✅ Static images auto-rotate imageTip outward when orbiting
4. ✅ Custom orbitImagePoint allows off-center orbital effects
5. ✅ No TypeScript errors
6. ✅ 60fps performance maintained
7. ✅ Code follows existing architecture pattern

---

## 📚 Reference Files

**Key files to understand:**

- `/app/shared/layer/LayerCore.ts` - Basic layer logic
- `/app/shared/layer/LayerCorePipeline.ts` - Pipeline infrastructure
- `/app/shared/layer/LayerCorePipelineSpin.ts` - Spin implementation (reference)
- `/app/shared/stages/StageCanvas.tsx` - How processors are used
- `/app/shared/config/ConfigYuzha.json` - Config structure

**Documentation:**

- `/app/attached_assets/ARCHITECTURE_FLOW_*.md` - Architecture explanation
- `/app/attached_assets/HOW_TO_ADD_NEW_LOGIC_*.md` - How to add processors
- `/app/attached_assets/spin_*.md` - Spin implementation details

---

## 🚀 Start Implementation

**Order of implementation:**

1. Create LayerCorePipelineOrbital.ts (core logic)
2. Update types (EnhancedLayerData, Config types)
3. Update JSON config (add orbital config to layers)
4. Integrate into stages (add to processor pipeline)
5. Update rendering engines (handle orbital rotation)
6. Test and verify

**Estimated time:** 2-3 hours for complete implementation and testing

---

**Document Version:** 1.0  
**Created:** 2025-01-06  
**Status:** Ready for Implementation 🚀
