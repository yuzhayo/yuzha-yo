# 🔄 Spin System - Complete Documentation & Implementation Plan

## 📋 Table of Contents
1. [Current State Analysis](#current-state-analysis)
2. [Architecture Vision](#architecture-vision)
3. [Spin Behavior Specification](#spin-behavior-specification)
4. [Data Flow](#data-flow)
5. [Implementation Plan](#implementation-plan)
6. [Code Examples](#code-examples)
7. [Testing Plan](#testing-plan)

---

## 🔍 Current State Analysis

### What Exists ✅

#### 1. **LayerCore.ts** - Basic Config Processor
- Calculates `UniversalLayerData` from config
- Computes `imageMapping` with:
  - `imageCenter`: Geometric center of image
  - `imageTip`: Point at edge in tip direction (default 90°)
  - `imageBase`: Point at edge in base direction (default 270°)
  - `displayRotation`: Rotation needed to orient image (calculated from tip/base)
- Provides foundation for all layer processing

#### 2. **LayerCorePipeline.ts** - Pipeline Infrastructure
- Defines `LayerProcessor` type: function that transforms layer data
- Defines `EnhancedLayerData` type: extended layer data with additional properties
- Functions: `runPipeline()`, `processBatch()`
- Ready to be used but **NOT currently integrated**

#### 3. **LayerCorePipelineSpin.ts** - Spin Processor (Needs Rewrite)
- Implements `createSpinProcessor()` factory function
- Calculates `currentRotation` based on elapsed time
- **Current Issue**: Implementation exists but doesn't follow the intended architecture

#### 4. **LayerEngineCanvas.ts** - Canvas Renderer
- Renders layers using Canvas 2D API
- **Current Issue**: Only uses `displayRotation`, ignores spin properties
- Has animation loop but doesn't update rotation over time

#### 5. **LayerEngineThree.ts** - Three.js Renderer
- Renders layers using Three.js WebGL
- **Current Issue**: Static render, doesn't handle spin animation
- Needs animation loop for time-based updates

#### 6. **Config Files**
- `ConfigYuzha.json`: Contains complete preset for each layer
  - Basic Config group (renderer, order, imageId, scale, position, imageTip, imageBase)
  - Spin Config group (spinCenter, spinSpeed, spinDirection)
- `Config.ts`: Transforms grouped JSON to flat `LayerConfigEntry`

#### 7. **Stage Components**
- `StageCanvas.tsx`: Mounts Canvas renderer
- `StageThree.tsx`: Mounts Three.js renderer
- **Current Issue**: Don't use pipeline, pass raw data to engines

---

### What Needs to Change ❌

1. ❌ **LayerCorePipelineSpin.ts**: Rewrite to align with architecture vision
2. ❌ **LayerEngineCanvas.ts**: Update to consume EnhancedLayerData and handle spin modes
3. ❌ **LayerEngineThree.ts**: Same as Canvas, add animation loop
4. ❌ **StageCanvas.tsx**: Integrate pipeline, create processors, pass enhanced data
5. ❌ **StageThree.tsx**: Same as Canvas
6. ❌ **Type Definitions**: Ensure EnhancedLayerData has all required spin properties

---

## 🏗️ Architecture Vision

### Core Principle
**"CSS-like Logic → Engine Native Implementation"**

The pipeline provides high-level instructions (like CSS), and each engine uses its native capabilities to achieve the intended result.

### Layer Processing Flow

```
┌─────────────────────────────────────────────────────────────┐
│ JSON Config (Complete Preset per Layer)                     │
│ - Basic Config: renderer, imageId, position, scale, etc.   │
│ - Spin Config: spinCenter, spinSpeed, spinDirection        │
│ - [Future]: Orbital Config, Filter Config, etc.            │
└─────────────────────────────────┬───────────────────────────┘
                                  ↓
┌─────────────────────────────────────────────────────────────┐
│ Layer Processors (Pipeline)                                 │
│                                                              │
│  1. prepareLayer() → UniversalLayerData                     │
│     - Loads image                                           │
│     - Computes imageMapping (center, tip, base, rotation)  │
│     - Calculates position & scale transforms               │
│                                                              │
│  2. Spin Processor (if spinSpeed defined)                  │
│     - Calculates currentRotation from elapsed time         │
│     - Determines rotation pivot (spinCenter)               │
│     - Adds spin properties to layer data                   │
│                                                              │
│  3. [Future Processors]                                    │
│     - Orbital motion processor                             │
│     - Opacity/filter processor                             │
│     - etc.                                                  │
│                                                              │
│  Output: EnhancedLayerData                                 │
└─────────────────────────────────┬───────────────────────────┘
                                  ↓
┌─────────────────────────────────────────────────────────────┐
│ Layer Engine (Canvas or Three.js)                          │
│                                                              │
│ - Receives FINAL processed EnhancedLayerData               │
│ - Uses native rendering capabilities                       │
│ - Translates high-level instructions to native API calls   │
│ - Handles animation loop (requestAnimationFrame)           │
└─────────────────────────────────┬───────────────────────────┘
                                  ↓
┌─────────────────────────────────────────────────────────────┐
│ Stage Component (StageCanvas or StageThree)                │
│                                                              │
│ - Orchestrates pipeline → engine flow                      │
│ - Manages lifecycle (mount/unmount)                        │
│ - Handles canvas/container setup                           │
└─────────────────────────────────┬───────────────────────────┘
                                  ↓
                            🖥️ DISPLAY
```

---

## 🎯 Spin Behavior Specification

### Spin Configuration Properties

```typescript
type SpinConfig = {
  spinCenter?: [number, number];  // [x, y] in 0-100% of image dimensions
  spinSpeed?: number;              // Degrees per second (0 = static)
  spinDirection?: "cw" | "ccw";    // Clockwise or counter-clockwise
}
```

All properties are **optional** and can be null/empty.

---

### 1. spinCenter - Rotation Pivot Point

**Purpose**: Defines the pivot point for rotation within the image.

**Coordinate System**: Percentage relative to image dimensions (0-100%)
- `[0, 0]` = Top-left corner of image
- `[50, 50]` = Center of image (default)
- `[100, 100]` = Bottom-right corner of image
- `[30, 70]` = 30% from left, 70% from top

**Default Behavior**:
```typescript
if (!spinCenter || spinCenter === null) {
  spinCenter = [50, 50]; // Use imageCenter from imageMapping
}
```

**Conversion to Pixels**:
```typescript
const spinCenterPixels = {
  x: (spinCenter[0] / 100) * imageDimensions.width,
  y: (spinCenter[1] / 100) * imageDimensions.height
};
```

**Visual Effect**:
- Center pivot `[50, 50]`: Symmetric rotation
- Off-center pivot `[30, 70]`: Asymmetric rotation (wobble effect)
- **IMPORTANT**: Image stays at its stage position, only rotates around internal pivot
- **NO orbital motion** - this is like CSS `transform-origin`

---

### 2. spinSpeed - Two Modes of Operation

#### Mode 1: STATIC Mode (spinSpeed = 0 or null or undefined)

**Behavior**:
```typescript
if (!spinSpeed || spinSpeed === 0) {
  // Use displayRotation calculated from imageTip/imageBase
  const rotation = imageMapping.displayRotation;
  // Image is oriented correctly but DOES NOT SPIN
}
```

**Use Case**: Image needs orientation correction but should remain static
**Example**: Arrow pointing in specific direction, static clock face

---

#### Mode 2: SPIN Mode (spinSpeed > 0)

**Behavior**:
```typescript
if (spinSpeed > 0) {
  // Calculate rotation based on elapsed time
  const elapsed = (currentTime - startTime) / 1000; // seconds
  let currentRotation = (elapsed * spinSpeed) % 360;
  
  // Apply direction
  if (spinDirection === "ccw") {
    currentRotation = -currentRotation;
  }
  
  // REPLACES displayRotation (not added to it)
  const rotation = currentRotation;
}
```

**Key Points**:
- ✅ **Starts from 0°** (ignores displayRotation from imageTip/imageBase)
- ✅ **Overrides** static rotation completely
- ✅ Continuous animation based on time
- ✅ Direction controlled by spinDirection

**Use Case**: Rotating gears, spinning wheels, animated clock hands
**Example**: Gear rotating at 5°/sec clockwise

---

### 3. spinDirection - Rotation Direction

**Values**:
- `"cw"` (clockwise): Positive rotation, increases angle over time
- `"ccw"` (counter-clockwise): Negative rotation, decreases angle over time

**Default**: `"cw"` if not specified

**Implementation**:
```typescript
const spinDirection = config.spinDirection || "cw";
if (spinDirection === "ccw") {
  currentRotation = -currentRotation;
}
```

---

## 📊 Data Flow Detailed

### Input: JSON Config (Complete Preset)

```json
{
  "layerId": "clock-GEARMOON",
  "groups": {
    "Basic Config": {
      "renderer": "2D",
      "order": 150,
      "imageId": "GEARMOON",
      "scale": [100, 100],
      "position": [1024, 1024],
      "imageTip": 90,
      "imageBase": 270
    },
    "Spin Config": {
      "spinCenter": [50, 50],
      "spinSpeed": 5,
      "spinDirection": "cw"
    }
  }
}
```

---

### Step 1: Basic Config Processing

**Function**: `prepareLayer(entry, stageSize)`

**Input**: `LayerConfigEntry` (flattened from groups)

**Output**: `UniversalLayerData`
```typescript
{
  layerId: "clock-GEARMOON",
  imageId: "GEARMOON",
  imageUrl: "blob:http://...",
  imagePath: "shared/Asset/gear-moon.png",
  position: { x: 1024, y: 1024 },
  scale: { x: 1.0, y: 1.0 },
  imageMapping: {
    imageCenter: { x: 512, y: 512 },      // 50% of 1024x1024 image
    imageTip: { x: 512, y: 0 },           // Top edge (90°)
    imageBase: { x: 512, y: 1024 },       // Bottom edge (270°)
    imageDimensions: { width: 1024, height: 1024 },
    displayAxisAngle: 90,
    displayRotation: 0,                    // Tip→Base axis already vertical
    axisCenterOffset: { x: 0, y: 0 }
  }
}
```

---

### Step 2: Spin Processing

**Function**: `createSpinProcessor(config)` returns processor function

**Processor Input**: `UniversalLayerData` + `timestamp`

**Processor Output**: `EnhancedLayerData`
```typescript
{
  ...UniversalLayerData,                   // All basic properties
  
  // Spin properties added:
  spinCenter: { x: 512, y: 512 },         // 50% of 1024x1024 = center
  spinSpeed: 5,                            // 5 degrees/second
  spinDirection: "cw",                     // Clockwise
  currentRotation: 73.5,                   // Calculated from elapsed time
  
  // Metadata:
  hasSpinAnimation: true                   // Flag for engine
}
```

**Calculation Example**:
```typescript
// At timestamp = 14700ms (14.7 seconds elapsed)
elapsed = 14.7 seconds
currentRotation = (14.7 * 5) % 360 = 73.5 degrees
// Gear has rotated 73.5° clockwise
```

---

### Step 3: Engine Rendering

**Engine receives**: `EnhancedLayerData`

**Engine decision logic**:
```typescript
function render(layer: EnhancedLayerData) {
  // Determine rotation mode
  const isSpinning = layer.spinSpeed && layer.spinSpeed > 0;
  
  if (isSpinning) {
    // SPIN MODE
    rotation = layer.currentRotation || 0;
    pivot = layer.spinCenter || layer.imageMapping.imageCenter;
  } else {
    // STATIC MODE
    rotation = layer.imageMapping.displayRotation || 0;
    pivot = layer.imageMapping.imageCenter;
  }
  
  // Render using native API
  renderImageWithRotation(
    layer.imageUrl,
    layer.position,      // Stage position (FIXED)
    layer.scale,
    rotation,            // Rotation angle
    pivot                // Rotation pivot point
  );
}
```

---

## 🔧 Implementation Plan

### Phase 1: Rewrite LayerCorePipelineSpin.ts ⚠️ CRITICAL

**Goal**: Align spin processor with architecture vision

**Changes**:
1. Update `EnhancedLayerData` type definition to include all spin properties
2. Rewrite `createSpinProcessor()` to:
   - Accept complete spin config (spinCenter, spinSpeed, spinDirection)
   - Default spinCenter to imageMapping.imageCenter if not provided
   - Convert spinCenter from percentage to pixels
   - Calculate currentRotation starting from 0° (not from displayRotation)
   - Return processor that adds spin properties to layer data
   - Add `hasSpinAnimation` flag for engine to detect spin mode

**New Code Structure**:
```typescript
import type { UniversalLayerData } from "./LayerCore";
import type { LayerProcessor } from "./LayerCorePipeline";

export type SpinConfig = {
  spinCenter?: [number, number];  // 0-100% coordinates
  spinSpeed?: number;              // Degrees per second (0 = no spin)
  spinDirection?: "cw" | "ccw";
};

export type EnhancedLayerData = UniversalLayerData & {
  spinCenter?: { x: number; y: number };  // Pixel coordinates
  spinSpeed?: number;
  spinDirection?: "cw" | "ccw";
  currentRotation?: number;                // Degrees
  hasSpinAnimation?: boolean;              // Flag for engines
};

export function createSpinProcessor(config: SpinConfig): LayerProcessor {
  const spinSpeed = config.spinSpeed ?? 0;
  const spinDirection = config.spinDirection ?? "cw";
  const spinCenterPercent = config.spinCenter;
  
  // If no spin, return passthrough processor
  if (spinSpeed === 0) {
    return (layer: UniversalLayerData): EnhancedLayerData => ({
      ...layer,
      hasSpinAnimation: false
    });
  }
  
  // Track start time for this processor instance
  let startTime: number | null = null;
  
  return (layer: UniversalLayerData, timestamp?: number): EnhancedLayerData => {
    const currentTime = timestamp ?? performance.now();
    
    // Initialize start time on first call
    if (startTime === null) {
      startTime = currentTime;
    }
    
    // Calculate elapsed time in seconds
    const elapsed = (currentTime - startTime) / 1000;
    
    // Calculate rotation starting from 0°
    let currentRotation = (elapsed * spinSpeed) % 360;
    
    // Apply direction
    if (spinDirection === "ccw") {
      currentRotation = -currentRotation;
    }
    
    // Determine spin center (default to imageCenter)
    let spinCenterPixels: { x: number; y: number };
    
    if (spinCenterPercent) {
      // Convert percentage to pixels
      const { width, height } = layer.imageMapping.imageDimensions;
      spinCenterPixels = {
        x: (spinCenterPercent[0] / 100) * width,
        y: (spinCenterPercent[1] / 100) * height
      };
    } else {
      // Default to image center
      spinCenterPixels = layer.imageMapping.imageCenter;
    }
    
    return {
      ...layer,
      spinCenter: spinCenterPixels,
      spinSpeed,
      spinDirection,
      currentRotation,
      hasSpinAnimation: true
    };
  };
}
```

---

### Phase 2: Update Layer Engines

#### 2.1 Update LayerEngineCanvas.ts

**Goal**: Consume EnhancedLayerData and render with spin support

**Changes**:
1. Import EnhancedLayerData type
2. Accept processor arrays for time-based updates
3. Update render logic to choose rotation mode (static vs spin)
4. Apply rotation around correct pivot point
5. Update animation loop to run pipeline each frame

**New Function Signature**:
```typescript
import type { UniversalLayerData } from "./LayerCore";
import type { EnhancedLayerData, LayerProcessor } from "./LayerCorePipeline";
import { runPipeline } from "./LayerCorePipeline";

export async function mountCanvasLayers(
  ctx: CanvasRenderingContext2D,
  layerDataArray: UniversalLayerData[],
  processorArrays?: LayerProcessor[][]  // One processor array per layer
): Promise<() => void>
```

**New Render Logic**:
```typescript
const render = (timestamp: number) => {
  ctx.clearRect(0, 0, STAGE_SIZE, STAGE_SIZE);
  
  for (let i = 0; i < layers.length; i++) {
    const { image, data: baseData } = layers[i];
    const processors = processorArrays?.[i] || [];
    
    // Run pipeline to get enhanced data
    const layerData: EnhancedLayerData = processors.length > 0
      ? runPipeline(baseData, processors, timestamp)
      : (baseData as EnhancedLayerData);
    
    const width = image.width * layerData.scale.x;
    const height = image.height * layerData.scale.y;
    
    // Determine rotation and pivot
    let rotation: number;
    let pivot: { x: number; y: number };
    
    if (layerData.hasSpinAnimation && layerData.spinSpeed && layerData.spinSpeed > 0) {
      // SPIN MODE - use currentRotation
      rotation = layerData.currentRotation || 0;
      pivot = layerData.spinCenter || layerData.imageMapping.imageCenter;
    } else {
      // STATIC MODE - use displayRotation
      rotation = layerData.imageMapping.displayRotation || 0;
      pivot = layerData.imageMapping.imageCenter;
    }
    
    ctx.save();
    
    // Apply rotation around pivot point
    // Pivot is in image-local coordinates, need to transform to stage coordinates
    const pivotX = (pivot.x / image.width) * width;
    const pivotY = (pivot.y / image.height) * height;
    
    // Translate to stage position + pivot offset
    ctx.translate(layerData.position.x, layerData.position.y);
    
    // Rotate around pivot
    ctx.translate(pivotX, pivotY);
    ctx.rotate((rotation * Math.PI) / 180);
    ctx.translate(-pivotX, -pivotY);
    
    // Draw image centered at origin
    ctx.drawImage(image, -width / 2, -height / 2, width, height);
    
    ctx.restore();
  }
};

let animationId: number;
const animate = (timestamp: number) => {
  render(timestamp);
  animationId = requestAnimationFrame(animate);
};
animationId = requestAnimationFrame(animate);
```

---

#### 2.2 Update LayerEngineThree.ts

**Goal**: Same as Canvas but using Three.js API

**Changes**:
1. Accept processor arrays
2. Store mesh references for updates
3. Create animation loop that updates mesh rotation
4. Handle pivot offset in Three.js coordinate system

**Key Implementation**:
```typescript
export async function mountThreeLayers(
  scene: THREE.Scene,
  layerDataArray: UniversalLayerData[],
  processorArrays?: LayerProcessor[][]
): Promise<() => void> {
  
  const meshesWithData: Array<{
    mesh: THREE.Mesh;
    baseData: UniversalLayerData;
    processors: LayerProcessor[];
  }> = [];
  
  // ... load textures and create meshes ...
  
  // Animation function
  const animate = (timestamp: number) => {
    for (const item of meshesWithData) {
      const layerData: EnhancedLayerData = item.processors.length > 0
        ? runPipeline(item.baseData, item.processors, timestamp)
        : (item.baseData as EnhancedLayerData);
      
      // Determine rotation
      let rotation: number;
      if (layerData.hasSpinAnimation && layerData.spinSpeed && layerData.spinSpeed > 0) {
        rotation = layerData.currentRotation || 0;
      } else {
        rotation = layerData.imageMapping.displayRotation || 0;
      }
      
      // Apply rotation to mesh
      item.mesh.rotation.z = (rotation * Math.PI) / 180;
      
      // Handle pivot offset if spinCenter !== imageCenter
      // (Three.js rotation is always around mesh center, may need position adjustment)
    }
    
    requestAnimationFrame(animate);
  };
  
  animate(performance.now());
  
  // Return cleanup function
  return () => { /* dispose meshes */ };
}
```

---

### Phase 3: Update Stage Components

#### 3.1 Update StageCanvas.tsx

**Goal**: Integrate pipeline, create processors, pass to engine

**Changes**:
```typescript
import React, { useEffect, useRef } from "react";
import { loadLayerConfig } from "../config/Config";
import { is2DLayer, prepareLayer } from "../layer/LayerCore";
import { mountCanvasLayers } from "../layer/LayerEngineCanvas";
import { createSpinProcessor } from "../layer/LayerCorePipelineSpin";
import type { LayerProcessor } from "../layer/LayerCorePipeline";
import { STAGE_SIZE, createStageTransformer } from "../utils/stage2048";

export default function StageCanvas() {
  const containerRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const container = containerRef.current;
    const canvas = canvasRef.current;
    if (!container || !canvas) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) {
      console.error("Failed to get 2D context");
      return;
    }

    canvas.width = STAGE_SIZE;
    canvas.height = STAGE_SIZE;

    let cleanupLayers: (() => void) | undefined;
    let cleanupTransform: (() => void) | undefined;

    const run = async () => {
      const config = loadLayerConfig();
      const twoDLayers = config.filter(is2DLayer);

      const layers = [];
      const processorArrays: LayerProcessor[][] = [];

      for (const entry of twoDLayers) {
        const layer = await prepareLayer(entry, STAGE_SIZE);
        if (!layer) {
          console.warn(`[StageCanvas] Skipping layer ${entry.layerId} - failed to prepare`);
          continue;
        }
        
        layers.push(layer);
        
        // Create processors for this layer
        const processors: LayerProcessor[] = [];
        
        // Add spin processor if configured
        if (entry.spinSpeed !== undefined) {
          processors.push(createSpinProcessor({
            spinCenter: entry.spinCenter,
            spinSpeed: entry.spinSpeed,
            spinDirection: entry.spinDirection
          }));
        }
        
        // [Future]: Add more processors here
        // if (entry.opacityConfig) { processors.push(createOpacityProcessor(...)); }
        
        processorArrays.push(processors);
      }

      cleanupLayers = await mountCanvasLayers(ctx, layers, processorArrays);
    };

    run().catch((error) => {
      console.error("Failed to initialise Canvas stage", error);
    });

    cleanupTransform = createStageTransformer(canvas, container, {
      resizeDebounce: 100,
    });

    return () => {
      cleanupTransform?.();
      cleanupLayers?.();
    };
  }, []);

  return (
    <div ref={containerRef} className="absolute inset-0 z-0 pointer-events-none">
      <canvas ref={canvasRef} className="block" />
    </div>
  );
}
```

---

#### 3.2 Update StageThree.tsx

**Goal**: Same as StageCanvas but for Three.js

**Changes**: Mirror the structure of StageCanvas.tsx, but call `mountThreeLayers` instead.

---

### Phase 4: Type Definitions Update

**Goal**: Ensure type consistency across all files

**File**: `LayerCorePipeline.ts`

**Update EnhancedLayerData type**:
```typescript
import type { UniversalLayerData } from "./LayerCore";

export type LayerProcessor = (
  layer: UniversalLayerData,
  timestamp?: number
) => EnhancedLayerData;

export type EnhancedLayerData = UniversalLayerData & {
  // Spin properties
  spinCenter?: { x: number; y: number };
  spinSpeed?: number;
  spinDirection?: "cw" | "ccw";
  currentRotation?: number;
  hasSpinAnimation?: boolean;
  
  // Future properties
  opacity?: number;
  filters?: string[];
  orbitalCenter?: { x: number; y: number };
  orbitalRadius?: number;
  // ... more future enhancements
};

export function runPipeline(
  baseLayer: UniversalLayerData,
  processors: LayerProcessor[],
  timestamp?: number
): EnhancedLayerData {
  let enhanced: EnhancedLayerData = { ...baseLayer };
  
  for (const processor of processors) {
    enhanced = processor(enhanced, timestamp);
  }
  
  return enhanced;
}

export function processBatch(
  baseLayers: UniversalLayerData[],
  processors: LayerProcessor[],
  timestamp?: number
): EnhancedLayerData[] {
  return baseLayers.map((layer) => runPipeline(layer, processors, timestamp));
}
```

---

## 📝 Code Examples

### Example 1: Static Image with Orientation

**Config**:
```json
{
  "layerId": "arrow-pointer",
  "groups": {
    "Basic Config": {
      "renderer": "2D",
      "order": 100,
      "imageId": "ARROW",
      "scale": [100, 100],
      "position": [1024, 1024],
      "imageTip": 45,
      "imageBase": 225
    },
    "Spin Config": {
      "spinSpeed": 0
    }
  }
}
```

**Result**:
- Arrow image positioned at [1024, 1024]
- Rotated to point at 45° (northeast direction)
- Static, no animation
- Uses `displayRotation` calculated from imageTip/imageBase

---

### Example 2: Spinning Gear (Centered)

**Config**:
```json
{
  "layerId": "clock-GEARMOON",
  "groups": {
    "Basic Config": {
      "renderer": "2D",
      "order": 150,
      "imageId": "GEARMOON",
      "scale": [100, 100],
      "position": [1024, 1024],
      "imageTip": 90,
      "imageBase": 270
    },
    "Spin Config": {
      "spinCenter": [50, 50],
      "spinSpeed": 5,
      "spinDirection": "cw"
    }
  }
}
```

**Result**:
- Gear positioned at [1024, 1024]
- Rotates at 5°/sec clockwise
- Pivot point at image center [50%, 50%]
- Complete rotation takes 72 seconds (360° / 5°/sec)
- Ignores imageTip/imageBase orientation

---

### Example 3: Off-Center Spinning (Wobble Effect)

**Config**:
```json
{
  "layerId": "eccentric-wheel",
  "groups": {
    "Basic Config": {
      "renderer": "2D",
      "order": 200,
      "imageId": "WHEEL",
      "scale": [100, 100],
      "position": [1500, 1500]
    },
    "Spin Config": {
      "spinCenter": [30, 70],
      "spinSpeed": 10,
      "spinDirection": "ccw"
    }
  }
}
```

**Result**:
- Wheel positioned at [1500, 1500]
- Rotates at 10°/sec counter-clockwise
- Pivot point at [30%, 70%] of image (off-center)
- Creates asymmetric wobble effect
- Image stays at position, rotates around internal off-center pivot

---

### Example 4: Multiple Layers with Mixed Behaviors

**Config**:
```json
[
  {
    "layerId": "background",
    "groups": {
      "Basic Config": { "order": 10, "imageId": "BG" },
      "Spin Config": { "spinSpeed": 0 }
    }
  },
  {
    "layerId": "slow-gear",
    "groups": {
      "Basic Config": { "order": 20, "imageId": "GEAR1" },
      "Spin Config": { "spinSpeed": 2, "spinDirection": "cw" }
    }
  },
  {
    "layerId": "fast-gear",
    "groups": {
      "Basic Config": { "order": 30, "imageId": "GEAR2" },
      "Spin Config": { "spinSpeed": 8, "spinDirection": "ccw" }
    }
  }
]
```

**Result**:
- Background: Static, no rotation
- Slow gear: Rotates 2°/sec clockwise
- Fast gear: Rotates 8°/sec counter-clockwise
- All layers render simultaneously with independent behaviors

---

## 🧪 Testing Plan

### Test Cases

#### Test 1: Static Mode Validation
**Layer**: stars-background (spinSpeed: 0)
**Expected**:
- ✅ Image displays at configured position
- ✅ Uses displayRotation from imageTip/imageBase
- ✅ No animation, completely static
- ✅ No performance impact

**Validation**:
```typescript
console.log(layerData.hasSpinAnimation); // false
console.log(layerData.currentRotation);  // undefined
```

---

#### Test 2: Centered Spin Validation
**Layer**: clock-GEARMOON (spinSpeed: 5, spinCenter: [50, 50])
**Expected**:
- ✅ Image rotates smoothly at 5°/sec
- ✅ Rotation is clockwise
- ✅ Pivot point at image center
- ✅ Completes 360° in 72 seconds
- ✅ Maintains 60fps

**Validation**:
```typescript
// After 10 seconds
console.log(layerData.currentRotation); // ~50° (10 * 5)

// After 72 seconds
console.log(layerData.currentRotation % 360); // ~0° (back to start)
```

---

#### Test 3: Off-Center Spin Validation
**Create Test Layer**: spinCenter: [30, 70], spinSpeed: 10
**Expected**:
- ✅ Image rotates around off-center pivot
- ✅ Creates wobble/asymmetric effect
- ✅ Image position remains fixed on stage
- ✅ No orbital motion around stage

**Validation**:
- Visual inspection: Image appears to wobble but stays in place
- Position check: `layerData.position` remains constant

---

#### Test 4: Direction Validation
**Test Both Directions**:
- CW: Angle increases over time
- CCW: Angle decreases (negative) over time

**Validation**:
```typescript
// CW direction
const rotation1 = layerData.currentRotation; // 45°
// Wait 1 second
const rotation2 = layerData.currentRotation; // 50° (increased)

// CCW direction
const rotation1 = layerData.currentRotation; // 45°
// Wait 1 second
const rotation2 = layerData.currentRotation; // 40° (decreased)
```

---

#### Test 5: Multiple Layers Performance
**Config**: 10 layers with mixed spin speeds (0, 2, 5, 10, etc.)
**Expected**:
- ✅ All layers render correctly
- ✅ Each spins at independent speed
- ✅ Maintains 60fps
- ✅ No visual glitches or jitter

**Validation**:
- Use browser DevTools Performance tab
- Check frame rate stays above 55fps
- Verify no dropped frames during animation

---

#### Test 6: Pipeline Integration
**Verify**: Processors run each frame and update data
**Expected**:
- ✅ currentRotation updates every frame
- ✅ Timestamp is passed correctly
- ✅ Multiple processors can be chained (future)

**Validation**:
```typescript
// In engine render loop
console.log(`Frame ${frameCount}: rotation = ${layerData.currentRotation}`);
// Should see increasing values each frame
```

---

#### Test 7: Type Safety
**Verify**: TypeScript compilation succeeds
**Expected**:
- ✅ No type errors in LayerEngineCanvas.ts
- ✅ No type errors in LayerEngineThree.ts
- ✅ No type errors in Stage components
- ✅ EnhancedLayerData fully compatible with UniversalLayerData

---

### Testing Checklist

- [ ] **Phase 1 Complete**: LayerCorePipelineSpin.ts rewritten and tested
- [ ] **Phase 2.1 Complete**: LayerEngineCanvas.ts updated and tested
- [ ] **Phase 2.2 Complete**: LayerEngineThree.ts updated and tested
- [ ] **Phase 3.1 Complete**: StageCanvas.tsx integrated with pipeline
- [ ] **Phase 3.2 Complete**: StageThree.tsx integrated with pipeline
- [ ] **Test 1 Passed**: Static mode works correctly
- [ ] **Test 2 Passed**: Centered spin works correctly
- [ ] **Test 3 Passed**: Off-center spin works correctly
- [ ] **Test 4 Passed**: Both spin directions work correctly
- [ ] **Test 5 Passed**: Multiple layers perform well
- [ ] **Test 6 Passed**: Pipeline integration works correctly
- [ ] **Test 7 Passed**: No TypeScript errors
- [ ] **Final Validation**: All features working in production build

---

## 🚀 Implementation Order

### Sprint 1: Foundation (1-2 hours)
1. ✅ Rewrite LayerCorePipelineSpin.ts
2. ✅ Update EnhancedLayerData type in LayerCorePipeline.ts
3. ✅ Run TypeScript compilation to check types
4. ✅ Test spin processor in isolation (unit test)

### Sprint 2: Canvas Rendering (1-2 hours)
1. ✅ Update LayerEngineCanvas.ts
2. ✅ Update StageCanvas.tsx
3. ✅ Test static mode (spinSpeed: 0)
4. ✅ Test spin mode (clock-GEARMOON)
5. ✅ Verify 60fps performance

### Sprint 3: Three.js Rendering (1-2 hours)
1. ✅ Update LayerEngineThree.ts
2. ✅ Update StageThree.tsx
3. ✅ Test both static and spin modes
4. ✅ Verify parity with Canvas renderer

### Sprint 4: Testing & Polish (1 hour)
1. ✅ Run all test cases
2. ✅ Fix any bugs or issues
3. ✅ Performance profiling
4. ✅ Documentation review

**Total Estimated Time**: 4-7 hours

---

## 📌 Key Success Metrics

1. ✅ **Functional**: clock-GEARMOON spins at 5°/sec clockwise
2. ✅ **Functional**: Static layers remain static (spinSpeed: 0)
3. ✅ **Performance**: Maintains 60fps with multiple spinning layers
4. ✅ **Correctness**: Rotation happens around correct pivot point
5. ✅ **Extensibility**: Easy to add future processors (opacity, filters)
6. ✅ **Type Safety**: No TypeScript errors or type-casting workarounds
7. ✅ **Code Quality**: Clean, maintainable, well-documented code

---

## 🎯 Future Enhancements

After spin implementation is complete, the pipeline architecture enables:

1. **Opacity Processor**: Fade layers in/out over time
2. **Filter Processor**: Apply visual filters (blur, brightness, etc.)
3. **Orbital Motion Processor**: Move layers in circular paths
4. **Scale Animation Processor**: Grow/shrink layers over time
5. **Path Animation Processor**: Move layers along bezier curves
6. **Collision Detection Processor**: Detect layer overlaps
7. **Physics Processor**: Apply gravity, velocity, acceleration

All following the same pattern:
```
Config → Processor → EnhancedLayerData → Engine → Display
```

---

## 📚 References

- **LayerCore.ts**: Basic layer processing and image mapping
- **LayerCorePipeline.ts**: Pipeline infrastructure
- **ConfigYuzha.json**: Layer configuration format
- **Canvas API**: [MDN Canvas Tutorial](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial)
- **Three.js**: [Three.js Documentation](https://threejs.org/docs/)
- **CSS transform-origin**: Similar concept to spinCenter

---

**Document Version**: 1.0  
**Last Updated**: 2025-10-04  
**Status**: Ready for Implementation 🚀
