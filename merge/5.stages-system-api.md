# Stages System API - Advanced 3D Rendering Engine

> Professional 3D rendering system with WebGL acceleration and performance optimization

## 📋 Overview

The Stages System provides advanced 3D rendering capabilities built on Three.js, featuring WebGL acceleration, adaptive quality management, and comprehensive performance monitoring. This system delivers professional-grade 3D graphics with optimized rendering pipelines, spatial indexing, and memory management for production applications.

**Key Files**: `StagesEngine.ts`, `StagesRenderer.ts`, `StagesLogicPerformance.ts`, `StagesRendererMaterial.ts`  
**Dependencies**: `StagesTypes.ts`, Three.js, WebGL  
**Integration**: Consumes Logic System data, provides final rendered output

## 🔧 Core API

### StagesEngine Interface

```typescript
export class StagesEngine {
  private renderer: StagesRenderer;
  private scene: THREE.Scene;
  private camera: THREE.OrthographicCamera;
  private objects: Map<string, Object3D> = new Map();
  private performanceMonitor: StagesLogicPerformance;
  
  constructor(settings: StagesSettings) {
    this.setupRenderer(settings);
    this.setupScene();
    this.setupCamera(settings);
    this.setupPerformanceMonitoring();
  }
  
  /**
   * Add 3D object to the scene
   */
  public addObject(stageObject: StageObject): THREE.Object3D | null {
    const object3D = this.createObject3D(stageObject);
    if (!object3D) return null;
    
    this.objects.set(stageObject.id, object3D);
    this.scene.add(object3D);
    this.emitEvent('object:added', { id: stageObject.id, object: object3D });
    
    return object3D;
  }
  
  /**
   * Update existing 3D object
   */
  public updateObject(id: string, updates: StageObjectUpdate): boolean {
    const object = this.objects.get(id);
    if (!object) return false;
    
    this.applyUpdates(object, updates);
    this.emitEvent('object:updated', { id, object, updates });
    
    return true;
  }
  
  /**
   * Remove 3D object from scene
   */
  public removeObject(id: string): boolean {
    const object = this.objects.get(id);
    if (!object) return false;
    
    this.scene.remove(object);
    this.disposeObject(object);
    this.objects.delete(id);
    this.emitEvent('object:removed', { id });
    
    return true;
  }
  
  /**
   * Batch update multiple objects for performance
   */
  public batchUpdate(updates: StageUpdate[]): BatchUpdateResult {
    const results: UpdateResult[] = [];
    
    updates.forEach(update => {
      const success = this.updateObject(update.objectId, update);
      results.push({ objectId: update.objectId, success });
    });
    
    return {
      results,
      successCount: results.filter(r => r.success).length,
      totalCount: updates.length
    };
  }
  
  /**
   * Render the scene
   */
  public render(): RenderResult {
    const startTime = performance.now();
    
    // Update performance monitoring
    this.performanceMonitor.frameStart();
    
    // Perform rendering
    this.renderer.render(this.scene, this.camera);
    
    const endTime = performance.now();
    const renderTime = endTime - startTime;
    
    // Record performance metrics
    this.performanceMonitor.frameEnd(renderTime);
    
    return {
      renderTime,
      objectCount: this.objects.size,
      triangleCount: this.calculateTriangleCount(),
      fps: this.performanceMonitor.getCurrentFPS()
    };
  }
}
```

### StageObject Interface

```typescript
export interface StageObject {
  /** Unique object identifier */
  id: string;
  
  /** 3D position [x, y, z] */
  position: [number, number, number?];
  
  /** Rotation in radians [x, y, z] or single Z rotation */
  rotation?: number | [number, number, number];
  
  /** Scale factor [x, y, z] or uniform scale */
  scale?: number | [number, number, number];
  
  /** Object metadata and configuration */
  metadata?: StageObjectMetadata;
  
  /** Texture reference for rendering */
  texture?: THREE.Texture;
  
  /** Material configuration */
  material?: MaterialConfig;
  
  /** Visibility flag */
  visible?: boolean;
  
  /** Render order priority */
  renderOrder?: number;
}

export interface StageObjectMetadata {
  /** Object type for specialized handling */
  type?: 'sprite' | 'mesh' | 'light' | 'camera' | 'group';
  
  /** Geometry configuration */
  geometry?: GeometryConfig;
  
  /** Animation data */
  animation?: AnimationData;
  
  /** Physics properties */
  physics?: PhysicsProperties;
  
  /** Custom user data */
  userData?: Record<string, any>;
}

export interface QualitySettings {
  /** Anti-aliasing enabled */
  antialias: boolean;
  
  /** Shadow map resolution */
  shadowMapSize: number;
  
  /** Shader precision level */
  precision: 'lowp' | 'mediump' | 'highp';
  
  /** Post-processing effects enabled */
  enablePostProcessing: boolean;
  
  /** Anisotropic filtering level */
  anisotropy: number;
  
  /** Pixel ratio for high-DPI displays */
  pixelRatio: number;
}
```

#### Configuration Details

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `id` | `string` | - | **Required** - Unique object identifier |
| `position` | `[number, number, number?]` | `[0,0,0]` | 3D world position coordinates |
| `rotation` | `number \| [number, number, number]?` | `0` | Rotation in radians |
| `scale` | `number \| [number, number, number]?` | `1` | Scale factor (uniform or per-axis) |
| `metadata` | `StageObjectMetadata?` | `{}` | Object type and configuration data |
| `texture` | `THREE.Texture?` | `undefined` | Texture for material rendering |
| `material` | `MaterialConfig?` | `default` | Material configuration |
| `visible` | `boolean?` | `true` | Object visibility in scene |
| `renderOrder` | `number?` | `0` | Rendering priority order |

### StagesRenderer Interface

```typescript
export class StagesRenderer {
  private renderer: THREE.WebGLRenderer;
  private materialManager: StagesRendererMaterial;
  private meshManager: StagesRendererMesh;
  private qualitySettings: QualitySettings;
  
  constructor(quality: QualitySettings) {
    this.qualitySettings = quality;
    this.setupRenderer();
    this.setupManagers();
  }
  
  private setupRenderer(): void {
    this.renderer = new THREE.WebGLRenderer({
      antialias: this.qualitySettings.antialias,
      powerPreference: "high-performance",
      precision: this.qualitySettings.precision,
      alpha: true,
      premultipliedAlpha: false,
      preserveDrawingBuffer: false
    });
    
    this.renderer.setPixelRatio(this.qualitySettings.pixelRatio);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.renderer.shadowMap.setSize(this.qualitySettings.shadowMapSize, this.qualitySettings.shadowMapSize);
    
    // Enable extensions for better performance
    this.renderer.capabilities.getMaxAnisotropy = () => this.qualitySettings.anisotropy;
  }
  
  public render(scene: THREE.Scene, camera: THREE.Camera): void {
    // Pre-render optimizations
    this.updateFrustumCulling(camera);
    this.sortRenderQueue(scene);
    
    // Main render call
    this.renderer.render(scene, camera);
    
    // Post-render cleanup
    this.updatePerformanceMetrics();
  }
  
  public resize(width: number, height: number): void {
    this.renderer.setSize(width, height);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, this.qualitySettings.pixelRatio));
  }
  
  public updateQuality(newQuality: Partial<QualitySettings>): void {
    this.qualitySettings = { ...this.qualitySettings, ...newQuality };
    this.applyQualitySettings();
  }
  
  private applyQualitySettings(): void {
    this.renderer.shadowMap.setSize(this.qualitySettings.shadowMapSize, this.qualitySettings.shadowMapSize);
    this.renderer.setPixelRatio(this.qualitySettings.pixelRatio);
    
    // Update materials with new quality settings
    this.materialManager.updateQuality(this.qualitySettings);
  }
}
```

## 🎯 Primary Functions

### StagesEngine.addObject()

```typescript
function addObject(stageObject: StageObject): THREE.Object3D | null
```

**Primary object creation function** - converts stage objects to Three.js objects and adds to scene.

#### Parameters
- **`stageObject`**: Complete stage object configuration
- Validates geometry and material requirements
- Applies position, rotation, and scale transformations

#### Returns
- `THREE.Object3D`: Created 3D object instance
- `null`: If object creation failed due to invalid configuration

### StagesEngine.batchUpdate()

```typescript
function batchUpdate(updates: StageUpdate[]): BatchUpdateResult
```

**Performance-optimized batch processing** - applies multiple object updates in single operation.

#### Parameters
- **`updates`**: Array of object update operations
- Groups updates by type for cache efficiency
- Minimizes GPU state changes

#### Returns
`BatchUpdateResult` with success metrics and individual operation results.

### StagesRenderer.render()

```typescript
function render(scene: THREE.Scene, camera: THREE.Camera): void
```

**Main rendering function** - executes complete WebGL rendering pipeline.

#### Parameters
- **`scene`**: Three.js scene containing all objects
- **`camera`**: Camera defining view frustum and projection

#### Returns
Void - renders to attached canvas element with performance monitoring.

## 💻 Usage Examples

### Basic 3D Scene Setup

```typescript
import { StagesEngine, StageObject, QualitySettings } from './StagesEngine';

// Configure quality settings
const qualitySettings: QualitySettings = {
  antialias: true,
  shadowMapSize: 2048,
  precision: 'highp',
  enablePostProcessing: true,
  anisotropy: 16,
  pixelRatio: Math.min(window.devicePixelRatio, 2)
};

// Initialize 3D engine
const stagesEngine = new StagesEngine(qualitySettings);

// Create basic cube object
const cubeObject: StageObject = {
  id: 'main-cube',
  position: [0, 0, 0],
  rotation: [0, 0, 0],
  scale: [1, 1, 1],
  metadata: {
    type: 'mesh',
    geometry: {
      type: 'box',
      width: 2,
      height: 2,
      depth: 2
    }
  },
  material: {
    type: 'standard',
    color: 0xff6b6b,
    roughness: 0.4,
    metalness: 0.1
  },
  visible: true,
  renderOrder: 0
};

// Add to scene
const cubeObject3D = stagesEngine.addObject(cubeObject);
console.log(`Created 3D cube: ${cubeObject3D ? 'Success' : 'Failed'}`);

// Render the scene
const renderResult = stagesEngine.render();
console.log(`Rendered scene in ${renderResult.renderTime}ms with ${renderResult.objectCount} objects`);
```

### Advanced Scene with Lighting

```typescript
// Create comprehensive 3D scene with lighting and materials
async function createAdvancedScene(engine: StagesEngine) {
  // Add ambient lighting
  const ambientLight: StageObject = {
    id: 'ambient-light',
    position: [0, 0, 0],
    metadata: {
      type: 'light',
      lightType: 'ambient',
      intensity: 0.3,
      color: 0x404040
    }
  };
  
  // Add directional lighting
  const directionalLight: StageObject = {
    id: 'main-light',
    position: [10, 10, 5],
    rotation: [-Math.PI / 4, 0, 0],
    metadata: {
      type: 'light',
      lightType: 'directional',
      intensity: 1.0,
      color: 0xffffff,
      castShadow: true,
      shadowMapSize: 2048
    }
  };
  
  // Create material library
  const materials = {
    metal: {
      type: 'standard',
      color: 0x888888,
      roughness: 0.2,
      metalness: 0.8,
      envMapIntensity: 1.0
    },
    plastic: {
      type: 'standard',
      color: 0x44aa88,
      roughness: 0.6,
      metalness: 0.0
    },
    glass: {
      type: 'standard',
      color: 0xffffff,
      roughness: 0.0,
      metalness: 0.0,
      transparent: true,
      opacity: 0.3
    }
  };
  
  // Create multiple objects with different materials
  const sceneObjects: StageObject[] = [
    {
      id: 'metal-sphere',
      position: [-3, 0, 0],
      metadata: {
        type: 'mesh',
        geometry: { type: 'sphere', radius: 1, segments: 32 }
      },
      material: materials.metal
    },
    {
      id: 'plastic-cube',
      position: [0, 0, 0],
      rotation: [0, Math.PI / 4, 0],
      metadata: {
        type: 'mesh',
        geometry: { type: 'box', width: 1.5, height: 1.5, depth: 1.5 }
      },
      material: materials.plastic
    },
    {
      id: 'glass-cylinder',
      position: [3, 0, 0],
      metadata: {
        type: 'mesh',
        geometry: { type: 'cylinder', radius: 0.8, height: 2, segments: 16 }
      },
      material: materials.glass
    },
    {
      id: 'ground-plane',
      position: [0, -2, 0],
      scale: [10, 1, 10],
      metadata: {
        type: 'mesh',
        geometry: { type: 'plane', width: 1, height: 1 },
        receiveShadow: true
      },
      material: {
        type: 'standard',
        color: 0x333333,
        roughness: 0.8,
        metalness: 0.1
      }
    }
  ];
  
  // Add all objects to scene
  const results = [ambientLight, directionalLight, ...sceneObjects].map(obj => {
    const object3D = engine.addObject(obj);
    return { id: obj.id, success: object3D !== null };
  });
  
  console.log('Scene creation results:');
  results.forEach(result => {
    console.log(`- ${result.id}: ${result.success ? 'Created' : 'Failed'}`);
  });
  
  return results;
}

// Usage
createAdvancedScene(stagesEngine).then(results => {
  const successCount = results.filter(r => r.success).length;
  console.log(`Scene created with ${successCount}/${results.length} objects`);
});
```

### Performance-Optimized Batch Operations

```typescript
// High-performance batch processing for multiple objects
class SceneAnimator {
  private engine: StagesEngine;
  private animationQueue: AnimationUpdate[] = [];
  
  constructor(engine: StagesEngine) {
    this.engine = engine;
  }
  
  // Queue multiple animation updates
  public queueAnimation(objectId: string, animation: AnimationUpdate): void {
    this.animationQueue.push({ objectId, ...animation });
  }
  
  // Process all queued animations in batch
  public processAnimationBatch(): BatchUpdateResult {
    if (this.animationQueue.length === 0) {
      return { results: [], successCount: 0, totalCount: 0 };
    }
    
    // Convert animations to stage updates
    const stageUpdates: StageUpdate[] = this.animationQueue.map(anim => ({
      objectId: anim.objectId,
      position: anim.position,
      rotation: anim.rotation,
      scale: anim.scale,
      material: anim.material
    }));
    
    // Batch update all objects
    const result = this.engine.batchUpdate(stageUpdates);
    
    // Clear queue
    this.animationQueue = [];
    
    console.log(`Batch processed: ${result.successCount}/${result.totalCount} updates successful`);
    return result;
  }
  
  // Animate rotating objects
  public animateRotation(objectIds: string[], rotationSpeed: number, deltaTime: number): void {
    const rotationDelta = rotationSpeed * (deltaTime / 1000);
    
    objectIds.forEach(id => {
      this.queueAnimation(id, {
        rotation: [0, rotationDelta, 0] // Rotate around Y axis
      });
    });
  }
  
  // Animate floating objects
  public animateFloating(objectIds: string[], amplitude: number, frequency: number, time: number): void {
    objectIds.forEach((id, index) => {
      const phase = (index * Math.PI * 2) / objectIds.length; // Distribute phases
      const yOffset = Math.sin(time * frequency + phase) * amplitude;
      
      this.queueAnimation(id, {
        position: [0, yOffset, 0] // Only update Y position
      });
    });
  }
}

// Usage example
const animator = new SceneAnimator(stagesEngine);

// Animation loop
function animate() {
  const time = Date.now() * 0.001; // Convert to seconds
  const deltaTime = 16.67; // Assume 60 FPS
  
  // Queue rotation animations
  animator.animateRotation(['metal-sphere', 'plastic-cube'], Math.PI, deltaTime);
  
  // Queue floating animations
  animator.animateFloating(['metal-sphere', 'plastic-cube', 'glass-cylinder'], 0.5, 2.0, time);
  
  // Process all animations in batch
  const batchResult = animator.processAnimationBatch();
  
  // Render scene
  const renderResult = stagesEngine.render();
  
  // Performance monitoring
  if (renderResult.fps < 30) {
    console.warn(`Low FPS detected: ${renderResult.fps.toFixed(1)}`);
  }
  
  requestAnimationFrame(animate);
}

animate();
```

### Adaptive Quality Management

```typescript
// Dynamic quality adjustment based on performance
class AdaptiveQualityManager {
  private engine: StagesEngine;
  private performanceHistory: number[] = [];
  private currentQualityLevel: 'low' | 'medium' | 'high' = 'high';
  private qualityProfiles: Record<string, Partial<QualitySettings>>;
  
  constructor(engine: StagesEngine) {
    this.engine = engine;
    this.setupQualityProfiles();
    this.startMonitoring();
  }
  
  private setupQualityProfiles(): void {
    this.qualityProfiles = {
      high: {
        antialias: true,
        shadowMapSize: 2048,
        precision: 'highp',
        enablePostProcessing: true,
        anisotropy: 16,
        pixelRatio: Math.min(window.devicePixelRatio, 2)
      },
      medium: {
        antialias: true,
        shadowMapSize: 1024,
        precision: 'mediump',
        enablePostProcessing: true,
        anisotropy: 8,
        pixelRatio: Math.min(window.devicePixelRatio, 1.5)
      },
      low: {
        antialias: false,
        shadowMapSize: 512,
        precision: 'lowp',
        enablePostProcessing: false,
        anisotropy: 1,
        pixelRatio: 1
      }
    };
  }
  
  private startMonitoring(): void {
    setInterval(() => {
      this.updatePerformanceHistory();
      this.adjustQuality();
    }, 1000); // Check every second
  }
  
  private updatePerformanceHistory(): void {
    const currentFPS = this.engine.getCurrentFPS();
    this.performanceHistory.push(currentFPS);
    
    // Keep only last 10 measurements
    if (this.performanceHistory.length > 10) {
      this.performanceHistory.shift();
    }
  }
  
  private adjustQuality(): void {
    if (this.performanceHistory.length < 3) return;
    
    const averageFPS = this.performanceHistory.reduce((a, b) => a + b) / this.performanceHistory.length;
    const targetFPS = 60;
    const lowThreshold = 30;
    const highThreshold = 55;
    
    let newQualityLevel = this.currentQualityLevel;
    
    if (averageFPS < lowThreshold && this.currentQualityLevel !== 'low') {
      // Reduce quality
      newQualityLevel = this.currentQualityLevel === 'high' ? 'medium' : 'low';
    } else if (averageFPS > highThreshold && this.currentQualityLevel !== 'high') {
      // Increase quality
      newQualityLevel = this.currentQualityLevel === 'low' ? 'medium' : 'high';
    }
    
    if (newQualityLevel !== this.currentQualityLevel) {
      console.log(`Adjusting quality: ${this.currentQualityLevel} → ${newQualityLevel} (FPS: ${averageFPS.toFixed(1)})`);
      this.applyQualityLevel(newQualityLevel);
      this.currentQualityLevel = newQualityLevel;
    }
  }
  
  private applyQualityLevel(level: 'low' | 'medium' | 'high'): void {
    const profile = this.qualityProfiles[level];
    this.engine.updateQuality(profile);
  }
  
  public getCurrentQuality(): string {
    return this.currentQualityLevel;
  }
  
  public getPerformanceMetrics(): PerformanceMetrics {
    const averageFPS = this.performanceHistory.reduce((a, b) => a + b, 0) / this.performanceHistory.length;
    
    return {
      averageFPS: averageFPS || 0,
      currentFPS: this.performanceHistory[this.performanceHistory.length - 1] || 0,
      qualityLevel: this.currentQualityLevel,
      objectCount: this.engine.getObjectCount(),
      renderTime: this.engine.getLastRenderTime()
    };
  }
}

// Usage
const qualityManager = new AdaptiveQualityManager(stagesEngine);

// Monitor performance periodically
setInterval(() => {
  const metrics = qualityManager.getPerformanceMetrics();
  console.log(`Performance: ${metrics.currentFPS.toFixed(1)} FPS, Quality: ${metrics.qualityLevel}, Objects: ${metrics.objectCount}`);
}, 5000);
```

### Comprehensive Scene Management

```typescript
// Complete scene management with asset loading and lifecycle
class StagesSceneManager {
  private engine: StagesEngine;
  private assetLoader: THREE.LoadingManager;
  private textureCache: Map<string, THREE.Texture> = new Map();
  private geometryCache: Map<string, THREE.BufferGeometry> = new Map();
  private scenes: Map<string, SceneData> = new Map();
  
  constructor(engine: StagesEngine) {
    this.engine = engine;
    this.setupAssetLoader();
  }
  
  private setupAssetLoader(): void {
    this.assetLoader = new THREE.LoadingManager();
    
    this.assetLoader.onLoad = () => {
      console.log('All assets loaded successfully');
    };
    
    this.assetLoader.onError = (url) => {
      console.error(`Failed to load asset: ${url}`);
    };
  }
  
  public async loadScene(sceneConfig: SceneConfig): Promise<LoadedScene> {
    console.log(`Loading scene: ${sceneConfig.id}`);
    
    // 1. Preload all required assets
    const assets = await this.preloadAssets(sceneConfig.assets);
    
    // 2. Create scene objects
    const objects = await this.createSceneObjects(sceneConfig.objects, assets);
    
    // 3. Setup lighting
    const lights = await this.createLighting(sceneConfig.lighting);
    
    // 4. Configure camera
    const camera = this.setupCamera(sceneConfig.camera);
    
    // 5. Store scene data
    const sceneData: SceneData = {
      id: sceneConfig.id,
      objects: [...objects, ...lights],
      camera,
      assets,
      metadata: sceneConfig.metadata
    };
    
    this.scenes.set(sceneConfig.id, sceneData);
    
    console.log(`Scene loaded: ${sceneConfig.id} with ${objects.length} objects and ${lights.length} lights`);
    
    return {
      id: sceneConfig.id,
      objectCount: objects.length,
      lightCount: lights.length,
      assetCount: Object.keys(assets).length
    };
  }
  
  private async preloadAssets(assetConfigs: AssetConfig[]): Promise<AssetMap> {
    const assets: AssetMap = {};
    const loader = new THREE.TextureLoader(this.assetLoader);
    
    const loadPromises = assetConfigs.map(async (config) => {
      if (this.textureCache.has(config.url)) {
        assets[config.id] = this.textureCache.get(config.url)!;
        return;
      }
      
      try {
        const texture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(config.url, resolve, undefined, reject);
        });
        
        // Configure texture
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.anisotropy = 16;
        
        this.textureCache.set(config.url, texture);
        assets[config.id] = texture;
      } catch (error) {
        console.error(`Failed to load texture: ${config.url}`, error);
      }
    });
    
    await Promise.all(loadPromises);
    return assets;
  }
  
  private async createSceneObjects(objectConfigs: StageObjectConfig[], assets: AssetMap): Promise<THREE.Object3D[]> {
    const objects: THREE.Object3D[] = [];
    
    for (const config of objectConfigs) {
      const stageObject: StageObject = {
        id: config.id,
        position: config.position,
        rotation: config.rotation,
        scale: config.scale,
        metadata: config.metadata,
        texture: assets[config.textureId],
        material: config.material,
        visible: config.visible ?? true
      };
      
      const object3D = this.engine.addObject(stageObject);
      if (object3D) {
        objects.push(object3D);
      }
    }
    
    return objects;
  }
  
  public unloadScene(sceneId: string): boolean {
    const sceneData = this.scenes.get(sceneId);
    if (!sceneData) return false;
    
    // Remove all scene objects
    sceneData.objects.forEach(object => {
      this.engine.removeObject(object.userData.id || object.uuid);
    });
    
    // Dispose assets if not used by other scenes
    this.cleanupAssets(sceneData.assets);
    
    this.scenes.delete(sceneId);
    console.log(`Scene unloaded: ${sceneId}`);
    
    return true;
  }
  
  private cleanupAssets(assets: AssetMap): void {
    Object.values(assets).forEach(asset => {
      if (asset instanceof THREE.Texture) {
        // Check if texture is used by other scenes
        const isUsedElsewhere = Array.from(this.scenes.values()).some(scene =>
          Object.values(scene.assets).includes(asset)
        );
        
        if (!isUsedElsewhere) {
          asset.dispose();
          // Remove from cache
          for (const [url, cachedTexture] of this.textureCache.entries()) {
            if (cachedTexture === asset) {
              this.textureCache.delete(url);
              break;
            }
          }
        }
      }
    });
  }
  
  public getSceneMetrics(sceneId: string): SceneMetrics | null {
    const sceneData = this.scenes.get(sceneId);
    if (!sceneData) return null;
    
    return {
      id: sceneId,
      objectCount: sceneData.objects.length,
      triangleCount: this.calculateSceneTriangles(sceneData.objects),
      memoryUsage: this.estimateSceneMemory(sceneData),
      renderComplexity: this.calculateRenderComplexity(sceneData.objects)
    };
  }
  
  private calculateSceneTriangles(objects: THREE.Object3D[]): number {
    return objects.reduce((total, object) => {
      if (object instanceof THREE.Mesh && object.geometry) {
        const positions = object.geometry.attributes.position;
        return total + (positions ? positions.count / 3 : 0);
      }
      return total;
    }, 0);
  }
  
  private estimateSceneMemory(sceneData: SceneData): number {
    let memoryEstimate = 0;
    
    // Estimate geometry memory
    sceneData.objects.forEach(object => {
      if (object instanceof THREE.Mesh && object.geometry) {
        const geometry = object.geometry;
        const vertices = geometry.attributes.position?.count || 0;
        memoryEstimate += vertices * 4 * 3; // 4 bytes per float, 3 floats per vertex
      }
    });
    
    // Estimate texture memory
    Object.values(sceneData.assets).forEach(asset => {
      if (asset instanceof THREE.Texture && asset.image) {
        const width = asset.image.width || 512;
        const height = asset.image.height || 512;
        memoryEstimate += width * height * 4; // 4 bytes per pixel (RGBA)
      }
    });
    
    return memoryEstimate;
  }
}

// Usage
const sceneManager = new StagesSceneManager(stagesEngine);

const forestSceneConfig: SceneConfig = {
  id: 'forest-environment',
  assets: [
    { id: 'tree-texture', url: './assets/tree-bark.jpg' },
    { id: 'ground-texture', url: './assets/forest-ground.jpg' },
    { id: 'leaf-texture', url: './assets/leaves.png' }
  ],
  objects: [
    {
      id: 'ground',
      position: [0, -1, 0],
      scale: [20, 1, 20],
      textureId: 'ground-texture',
      metadata: { type: 'mesh', geometry: { type: 'plane' } },
      material: { type: 'standard', roughness: 0.8 }
    },
    {
      id: 'tree-1',
      position: [-5, 0, -3],
      textureId: 'tree-texture',
      metadata: { type: 'mesh', geometry: { type: 'cylinder', height: 8, radius: 0.5 } },
      material: { type: 'standard', roughness: 0.9 }
    }
  ],
  lighting: {
    ambient: { intensity: 0.3, color: 0x404040 },
    directional: { intensity: 1.0, color: 0xffffff, position: [10, 10, 5] }
  },
  camera: {
    position: [0, 5, 10],
    target: [0, 0, 0]
  }
};

sceneManager.loadScene(forestSceneConfig).then(result => {
  console.log(`Forest scene loaded with ${result.objectCount} objects`);
  
  const metrics = sceneManager.getSceneMetrics('forest-environment');
  if (metrics) {
    console.log(`Scene metrics: ${metrics.triangleCount} triangles, ${(metrics.memoryUsage / 1024 / 1024).toFixed(1)}MB memory`);
  }
});
```

## 🔍 Implementation Details

### WebGL Rendering Pipeline

#### Renderer Optimization

```typescript
export class OptimizedStagesRenderer extends StagesRenderer {
  private renderQueue: RenderQueueItem[] = [];
  private frustumCuller: THREE.Frustum = new THREE.Frustum();
  private occlusionCuller: OcclusionCuller;
  
  constructor(quality: QualitySettings) {
    super(quality);
    this.occlusionCuller = new OcclusionCuller();
    this.setupOptimizations();
  }
  
  private setupOptimizations(): void {
    // Enable instancing for repeated geometry
    this.enableInstancing();
    
    // Setup render state batching
    this.setupStateBatching();
    
    // Configure LOD system
    this.setupLevelOfDetail();
  }
  
  public render(scene: THREE.Scene, camera: THREE.Camera): void {
    // Update frustum for culling
    this.updateFrustum(camera);
    
    // Build optimized render queue
    this.buildRenderQueue(scene);
    
    // Sort for optimal rendering
    this.sortRenderQueue();
    
    // Execute render passes
    this.executeRenderPasses();
    
    // Update performance metrics
    this.updateRenderMetrics();
  }
  
  private updateFrustum(camera: THREE.Camera): void {
    const matrix = new THREE.Matrix4();
    matrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this.frustumCuller.setFromProjectionMatrix(matrix);
  }
  
  private buildRenderQueue(scene: THREE.Scene): void {
    this.renderQueue = [];
    
    scene.traverse((object) => {
      if (!object.visible || !(object instanceof THREE.Mesh)) return;
      
      // Frustum culling
      if (!this.frustumCuller.intersectsObject(object)) return;
      
      // Occlusion culling (optional, CPU intensive)
      if (this.qualitySettings.enableOcclusion && this.occlusionCuller.isOccluded(object)) return;
      
      // Calculate distance for LOD and sorting
      const distance = this.calculateDistanceToCamera(object, camera);
      
      this.renderQueue.push({
        object,
        distance,
        material: object.material,
        geometry: object.geometry,
        renderOrder: object.renderOrder || 0
      });
    });
  }
  
  private sortRenderQueue(): void {
    this.renderQueue.sort((a, b) => {
      // Sort by render order first
      if (a.renderOrder !== b.renderOrder) {
        return a.renderOrder - b.renderOrder;
      }
      
      // Then by material to minimize state changes
      if (a.material !== b.material) {
        return a.material.id - b.material.id;
      }
      
      // Then by geometry
      if (a.geometry !== b.geometry) {
        return a.geometry.id - b.geometry.id;
      }
      
      // Finally by distance (back to front for transparency)
      return b.distance - a.distance;
    });
  }
  
  private executeRenderPasses(): void {
    // Opaque pass
    this.renderOpaqueObjects();
    
    // Transparent pass
    this.renderTransparentObjects();
    
    // Post-processing pass
    if (this.qualitySettings.enablePostProcessing) {
      this.renderPostProcessing();
    }
  }
  
  private renderOpaqueObjects(): void {
    const opaqueObjects = this.renderQueue.filter(item => !this.isTransparent(item.material));
    
    opaqueObjects.forEach(item => {
      this.renderer.renderBufferDirect(camera, scene, item.geometry, item.material, item.object, null);
    });
  }
  
  private renderTransparentObjects(): void {
    const transparentObjects = this.renderQueue.filter(item => this.isTransparent(item.material));
    
    // Enable blending for transparent objects
    this.renderer.state.setBlending(THREE.NormalBlending);
    
    transparentObjects.forEach(item => {
      this.renderer.renderBufferDirect(camera, scene, item.geometry, item.material, item.object, null);
    });
    
    // Disable blending
    this.renderer.state.setBlending(THREE.NoBlending);
  }
}
```

#### Material and Geometry Management

```typescript
export class StagesResourceManager {
  private materialCache: Map<string, THREE.Material> = new Map();
  private geometryCache: Map<string, THREE.BufferGeometry> = new Map();
  private textureCache: Map<string, THREE.Texture> = new Map();
  private instancedMeshes: Map<string, THREE.InstancedMesh> = new Map();
  
  public getMaterial(config: MaterialConfig): THREE.Material {
    const key = this.generateMaterialKey(config);
    
    let material = this.materialCache.get(key);
    if (!material) {
      material = this.createMaterial(config);
      this.materialCache.set(key, material);
    }
    
    return material.clone(); // Return clone to allow per-object modifications
  }
  
  private createMaterial(config: MaterialConfig): THREE.Material {
    switch (config.type) {
      case 'basic':
        return new THREE.MeshBasicMaterial({
          color: config.color || 0xffffff,
          transparent: config.transparent || false,
          opacity: config.opacity || 1.0,
          map: config.map || null
        });
      
      case 'standard':
        return new THREE.MeshStandardMaterial({
          color: config.color || 0xffffff,
          roughness: config.roughness || 0.5,
          metalness: config.metalness || 0.0,
          transparent: config.transparent || false,
          opacity: config.opacity || 1.0,
          map: config.map || null,
          normalMap: config.normalMap || null,
          roughnessMap: config.roughnessMap || null,
          metalnessMap: config.metalnessMap || null
        });
      
      case 'physical':
        return new THREE.MeshPhysicalMaterial({
          color: config.color || 0xffffff,
          roughness: config.roughness || 0.5,
          metalness: config.metalness || 0.0,
          clearcoat: config.clearcoat || 0.0,
          clearcoatRoughness: config.clearcoatRoughness || 0.0,
          transmission: config.transmission || 0.0,
          ior: config.ior || 1.5
        });
      
      default:
        return new THREE.MeshBasicMaterial({ color: 0xff00ff }); // Magenta for debugging
    }
  }
  
  public getGeometry(config: GeometryConfig): THREE.BufferGeometry {
    const key = this.generateGeometryKey(config);
    
    let geometry = this.geometryCache.get(key);
    if (!geometry) {
      geometry = this.createGeometry(config);
      this.geometryCache.set(key, geometry);
    }
    
    return geometry;
  }
  
  private createGeometry(config: GeometryConfig): THREE.BufferGeometry {
    switch (config.type) {
      case 'box':
        return new THREE.BoxGeometry(
          config.width || 1,
          config.height || 1,
          config.depth || 1,
          config.segments || 1
        );
      
      case 'sphere':
        return new THREE.SphereGeometry(
          config.radius || 1,
          config.segments || 32,
          config.rings || 16
        );
      
      case 'cylinder':
        return new THREE.CylinderGeometry(
          config.radiusTop || config.radius || 1,
          config.radiusBottom || config.radius || 1,
          config.height || 1,
          config.segments || 8
        );
      
      case 'plane':
        return new THREE.PlaneGeometry(
          config.width || 1,
          config.height || 1,
          config.segmentsWidth || 1,
          config.segmentsHeight || 1
        );
      
      default:
        return new THREE.BoxGeometry(1, 1, 1);
    }
  }
  
  // Instancing for repeated objects
  public createInstancedMesh(
    geometry: THREE.BufferGeometry,
    material: THREE.Material,
    count: number
  ): THREE.InstancedMesh {
    const instancedMesh = new THREE.InstancedMesh(geometry, material, count);
    
    // Set default transforms
    const matrix = new THREE.Matrix4();
    for (let i = 0; i < count; i++) {
      matrix.setPosition(0, 0, 0);
      instancedMesh.setMatrixAt(i, matrix);
    }
    
    instancedMesh.instanceMatrix.needsUpdate = true;
    return instancedMesh;
  }
  
  public dispose(): void {
    // Dispose all cached resources
    this.materialCache.forEach(material => material.dispose());
    this.geometryCache.forEach(geometry => geometry.dispose());
    this.textureCache.forEach(texture => texture.dispose());
    
    this.materialCache.clear();
    this.geometryCache.clear();
    this.textureCache.clear();
  }
}
```

## ⚡ Performance Characteristics

### Computational Complexity
- **Object Rendering**: O(n*log(n)) with spatial indexing and frustum culling
- **Material Switching**: O(1) with state batching and caching
- **Geometry Updates**: O(n) where n = vertex count for dynamic objects
- **Memory Usage**: O(n) scaling with object count and texture resolution

### GPU Memory Management

```typescript
export class GPUMemoryManager {
  private memoryUsage: MemoryTracker = {
    textures: 0,
    geometries: 0,
    materials: 0,
    total: 0
  };
  
  private memoryLimits: MemoryLimits = {
    textures: 512 * 1024 * 1024, // 512MB
    geometries: 256 * 1024 * 1024, // 256MB
    total: 1024 * 1024 * 1024 // 1GB
  };
  
  public trackTextureMemory(texture: THREE.Texture): void {
    const size = this.calculateTextureMemory(texture);
    this.memoryUsage.textures += size;
    this.memoryUsage.total += size;
    
    if (this.memoryUsage.textures > this.memoryLimits.textures) {
      this.freeOldestTextures();
    }
  }
  
  private calculateTextureMemory(texture: THREE.Texture): number {
    if (!texture.image) return 0;
    
    const width = texture.image.width || 512;
    const height = texture.image.height || 512;
    const bytesPerPixel = this.getBytesPerPixel(texture.format, texture.type);
    
    return width * height * bytesPerPixel;
  }
  
  private getBytesPerPixel(format: THREE.PixelFormat, type: THREE.TextureDataType): number {
    // Simplified calculation
    switch (format) {
      case THREE.RGBAFormat:
        return type === THREE.FloatType ? 16 : 4;
      case THREE.RGBFormat:
        return type === THREE.FloatType ? 12 : 3;
      default:
        return 4;
    }
  }
  
  public getMemoryReport(): MemoryReport {
    return {
      usage: { ...this.memoryUsage },
      limits: { ...this.memoryLimits },
      utilizationPercent: {
        textures: (this.memoryUsage.textures / this.memoryLimits.textures) * 100,
        total: (this.memoryUsage.total / this.memoryLimits.total) * 100
      }
    };
  }
}
```

---

The Stages System provides professional-grade 3D rendering capabilities with optimized performance characteristics and comprehensive resource management for production applications.