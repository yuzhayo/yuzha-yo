# Layer System API - Data Processing Foundation

> Comprehensive data processing, validation, and pipeline management system

## 📋 Overview

The Layer System serves as the foundation data processing layer, providing robust validation, type-safe data structures, and efficient pipeline management. This system handles the core data flow from configuration input through validated, processed layer objects ready for consumption by higher-level systems.

**Key Files**: `LayerEngine.ts`, `LayerManager.ts`, `LayerPipeline.ts`, `LayerValidator.ts`  
**Dependencies**: `LayerTypes.ts`, `LayerConfigRegistry.json`  
**Integration**: Foundation for Logic System and Stages System

## 🔧 Core API

### LayerConfig Interface

```typescript
export interface LayerConfig {
  /** Unique identifier for the layer */
  id: string;
  
  /** Layer type determining processing behavior */
  type: LayerType;
  
  /** 3D position in world coordinates */
  position: Vector3;
  
  /** Layer-specific properties and configuration */
  properties: LayerProperties;
  
  /** Optional parent layer for hierarchical organization */
  parent?: string;
  
  /** Z-index for rendering order */
  zIndex?: number;
  
  /** Visibility flag */
  visible?: boolean;
}

export type LayerType = 'mesh' | 'light' | 'camera' | 'group' | 'effect' | 'ui' | 'animation';

export interface LayerProperties {
  /** Material configuration */
  material?: MaterialConfig;
  
  /** Texture reference */
  texture?: string;
  
  /** Animation settings */
  animation?: AnimationConfig;
  
  /** Custom metadata */
  metadata?: Record<string, any>;
}

export interface Vector3 {
  x: number;
  y: number;
  z: number;
}
```

#### Configuration Details

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `id` | `string` | - | **Required** - Unique layer identifier |
| `type` | `LayerType` | - | **Required** - Processing behavior type |
| `position` | `Vector3` | `{0,0,0}` | World coordinate position |
| `properties` | `LayerProperties` | `{}` | Type-specific configuration |
| `parent` | `string?` | `undefined` | Parent layer for hierarchy |
| `zIndex` | `number?` | `0` | Rendering order priority |
| `visible` | `boolean?` | `true` | Visibility flag |

### LayerEngine Interface

```typescript
export class LayerEngine {
  private layers: Map<string, Layer> = new Map();
  private groups: Map<string, LayerGroup> = new Map();
  
  /**
   * Add a new layer to the engine
   */
  public addLayer(config: LayerConfig): Layer {
    const layer = LayerProducer.create(config.type, config);
    this.layers.set(config.id, layer);
    this.emitEvent('layer:added', layer);
    return layer;
  }
  
  /**
   * Update an existing layer
   */
  public updateLayer(id: string, updates: Partial<LayerConfig>): Layer | null {
    const layer = this.layers.get(id);
    if (!layer) return null;
    
    layer.update(updates);
    this.emitEvent('layer:updated', layer);
    return layer;
  }
  
  /**
   * Remove layer from engine
   */
  public removeLayer(id: string): boolean {
    const layer = this.layers.get(id);
    if (!layer) return false;
    
    layer.dispose();
    this.layers.delete(id);
    this.emitEvent('layer:removed', { id });
    return true;
  }
  
  /**
   * Get layer by ID
   */
  public getLayer(id: string): Layer | undefined {
    return this.layers.get(id);
  }
  
  /**
   * Get all layers
   */
  public getAllLayers(): Layer[] {
    return Array.from(this.layers.values());
  }
  
  /**
   * Batch operations for performance
   */
  public batch(operations: LayerOperation[]): BatchResult {
    const results: LayerOperationResult[] = [];
    
    operations.forEach(op => {
      try {
        const result = this.executeOperation(op);
        results.push({ operation: op, success: true, result });
      } catch (error) {
        results.push({ operation: op, success: false, error });
      }
    });
    
    return { results, successCount: results.filter(r => r.success).length };
  }
}
```

### LayerPipeline Interface

```typescript
export class LayerPipeline {
  private validators: LayerValidator[] = [];
  private processors: LayerProcessor[] = [];
  private optimizers: LayerOptimizer[] = [];
  
  /**
   * Process layer configurations through complete pipeline
   */
  public async process(
    configs: LayerConfig[],
    context: ProcessingContext = {}
  ): Promise<PipelineResult> {
    try {
      // 1. Validation phase
      const validationResult = await this.validate(configs);
      if (!validationResult.success) {
        return { success: false, errors: validationResult.errors };
      }
      
      // 2. Processing phase
      const processingResult = await this.processLayers(validationResult.data, context);
      
      // 3. Optimization phase
      const optimizedResult = await this.optimize(processingResult.data);
      
      return {
        success: true,
        data: optimizedResult.data,
        metadata: {
          validationTime: validationResult.time,
          processingTime: processingResult.time,
          optimizationTime: optimizedResult.time,
          totalLayers: optimizedResult.data.length
        }
      };
    } catch (error) {
      return { success: false, errors: [{ message: error.message, path: 'pipeline' }] };
    }
  }
  
  private async validate(configs: LayerConfig[]): Promise<ValidationResult> {
    const errors: ValidationError[] = [];
    const validatedConfigs: LayerConfig[] = [];
    
    for (const config of configs) {
      const result = LayerValidator.validateConfig(config);
      if (result.success) {
        validatedConfigs.push(result.data);
      } else {
        errors.push(...result.errors);
      }
    }
    
    return {
      success: errors.length === 0,
      data: validatedConfigs,
      errors,
      time: performance.now()
    };
  }
}
```

## 🎯 Primary Functions

### LayerEngine.addLayer()

```typescript
function addLayer(config: LayerConfig): Layer
```

**Primary layer creation function** - validates and instantiates layers within the engine.

#### Parameters
- **`config`**: Complete layer configuration object
- Validates all required fields and type consistency
- Applies default values for optional properties

#### Returns
Fully initialized `Layer` instance with engine registration.

### LayerManager.updateLayer()

```typescript
function updateLayer(id: string, updates: Partial<LayerConfig>): Layer | null
```

**Layer modification function** - applies updates with change detection and validation.

#### Parameters
- **`id`**: Target layer identifier
- **`updates`**: Partial configuration containing only changed properties

#### Returns
- `Layer`: Updated layer instance
- `null`: If layer not found

### LayerPipeline.process()

```typescript
async function process(
  configs: LayerConfig[], 
  context?: ProcessingContext
): Promise<PipelineResult>
```

**Complete pipeline processing** - validation, processing, and optimization in sequence.

#### Parameters
- **`configs`**: Array of layer configurations to process
- **`context`**: Optional processing context with environment settings

#### Returns
`PipelineResult` with processed data or validation errors.

## 💻 Usage Examples

### Basic Layer Creation

```typescript
import { LayerEngine, LayerConfig } from './LayerEngine';

// Initialize engine
const engine = new LayerEngine();

// Create basic mesh layer
const meshConfig: LayerConfig = {
  id: 'main-cube',
  type: 'mesh',
  position: { x: 0, y: 0, z: 0 },
  properties: {
    material: {
      type: 'basic',
      color: 0xff0000,
      wireframe: false
    },
    texture: './assets/cube-texture.png'
  },
  visible: true,
  zIndex: 1
};

const meshLayer = engine.addLayer(meshConfig);
console.log(`Created layer: ${meshLayer.id}`); // Created layer: main-cube
```

### Hierarchical Layer Organization

```typescript
// Create parent group layer
const groupConfig: LayerConfig = {
  id: 'scene-group',
  type: 'group',
  position: { x: 0, y: 0, z: 0 },
  properties: {
    metadata: { description: 'Main scene container' }
  }
};

const groupLayer = engine.addLayer(groupConfig);

// Create child layers
const childConfigs: LayerConfig[] = [
  {
    id: 'child-mesh-1',
    type: 'mesh',
    position: { x: 2, y: 0, z: 0 },
    parent: 'scene-group',
    properties: {
      material: { type: 'basic', color: 0x00ff00 }
    }
  },
  {
    id: 'child-light-1',
    type: 'light',
    position: { x: 0, y: 5, z: 0 },
    parent: 'scene-group',
    properties: {
      lightType: 'directional',
      intensity: 1.0,
      color: 0xffffff
    }
  }
];

// Add child layers
childConfigs.forEach(config => {
  const childLayer = engine.addLayer(config);
  console.log(`Added child: ${childLayer.id} to parent: ${config.parent}`);
});
```

### Batch Operations for Performance

```typescript
import { LayerOperation, BatchResult } from './LayerEngine';

// Define batch operations
const operations: LayerOperation[] = [
  {
    type: 'add',
    config: {
      id: 'batch-mesh-1',
      type: 'mesh',
      position: { x: 1, y: 0, z: 0 },
      properties: { material: { type: 'basic', color: 0xff0000 } }
    }
  },
  {
    type: 'add',
    config: {
      id: 'batch-mesh-2',
      type: 'mesh',
      position: { x: -1, y: 0, z: 0 },
      properties: { material: { type: 'basic', color: 0x0000ff } }
    }
  },
  {
    type: 'update',
    id: 'existing-layer',
    updates: { position: { x: 0, y: 2, z: 0 } }
  }
];

// Execute batch
const batchResult: BatchResult = engine.batch(operations);
console.log(`Batch completed: ${batchResult.successCount}/${operations.length} successful`);

// Handle any failures
batchResult.results.forEach(result => {
  if (!result.success) {
    console.error(`Operation failed:`, result.error);
  }
});
```

### Pipeline Processing Workflow

```typescript
import { LayerPipeline, ProcessingContext } from './LayerPipeline';

// Create pipeline instance
const pipeline = new LayerPipeline();

// Define layer configurations
const layerConfigs: LayerConfig[] = [
  {
    id: 'environment',
    type: 'group',
    position: { x: 0, y: 0, z: 0 },
    properties: {
      metadata: { environment: 'forest' }
    }
  },
  {
    id: 'terrain',
    type: 'mesh',
    position: { x: 0, y: -1, z: 0 },
    parent: 'environment',
    properties: {
      material: { type: 'standard', roughness: 0.8 },
      texture: './assets/terrain-texture.png'
    }
  },
  {
    id: 'ambient-light',
    type: 'light',
    position: { x: 0, y: 10, z: 0 },
    parent: 'environment',
    properties: {
      lightType: 'ambient',
      intensity: 0.3,
      color: 0x404040
    }
  }
];

// Define processing context
const context: ProcessingContext = {
  environment: 'development',
  enableOptimizations: true,
  targetFPS: 60,
  qualityLevel: 'high'
};

// Process through pipeline
async function processScene() {
  const result = await pipeline.process(layerConfigs, context);
  
  if (result.success) {
    console.log('Pipeline processing successful:');
    console.log(`- Processed ${result.metadata.totalLayers} layers`);
    console.log(`- Validation time: ${result.metadata.validationTime}ms`);
    console.log(`- Processing time: ${result.metadata.processingTime}ms`);
    console.log(`- Optimization time: ${result.metadata.optimizationTime}ms`);
    
    // Use processed data
    result.data.forEach(layer => {
      console.log(`Layer ${layer.id}: ${layer.type} at [${layer.position.x}, ${layer.position.y}, ${layer.position.z}]`);
    });
  } else {
    console.error('Pipeline processing failed:');
    result.errors.forEach(error => {
      console.error(`- ${error.path}: ${error.message}`);
    });
  }
}

processScene();
```

### Advanced Layer Management

```typescript
class SceneManager {
  private engine: LayerEngine;
  private activeScenes: Map<string, Scene> = new Map();
  
  constructor() {
    this.engine = new LayerEngine();
    this.setupEventListeners();
  }
  
  private setupEventListeners() {
    this.engine.on('layer:added', (layer) => {
      console.log(`Layer added: ${layer.id}`);
      this.updateSceneMetrics();
    });
    
    this.engine.on('layer:updated', (layer) => {
      console.log(`Layer updated: ${layer.id}`);
      this.invalidateCache(layer.id);
    });
    
    this.engine.on('layer:removed', ({ id }) => {
      console.log(`Layer removed: ${id}`);
      this.cleanupReferences(id);
    });
  }
  
  public async loadScene(sceneConfig: SceneConfig): Promise<Scene> {
    const scene = new Scene(sceneConfig.id);
    
    // Process all layer configurations
    const pipeline = new LayerPipeline();
    const result = await pipeline.process(sceneConfig.layers);
    
    if (!result.success) {
      throw new Error(`Scene loading failed: ${result.errors.map(e => e.message).join(', ')}`);
    }
    
    // Add layers to engine
    const layers: Layer[] = [];
    for (const layerData of result.data) {
      const layer = this.engine.addLayer(layerData);
      layers.push(layer);
      scene.addLayer(layer);
    }
    
    this.activeScenes.set(sceneConfig.id, scene);
    
    console.log(`Scene loaded: ${sceneConfig.id} with ${layers.length} layers`);
    return scene;
  }
  
  public getSceneMetrics(sceneId: string): SceneMetrics | null {
    const scene = this.activeScenes.get(sceneId);
    if (!scene) return null;
    
    const layers = scene.getLayers();
    return {
      layerCount: layers.length,
      typeDistribution: this.calculateTypeDistribution(layers),
      memoryUsage: this.calculateMemoryUsage(layers),
      renderComplexity: this.calculateRenderComplexity(layers)
    };
  }
  
  private calculateTypeDistribution(layers: Layer[]): Record<LayerType, number> {
    const distribution: Record<LayerType, number> = {
      mesh: 0, light: 0, camera: 0, group: 0, effect: 0, ui: 0, animation: 0
    };
    
    layers.forEach(layer => {
      distribution[layer.type]++;
    });
    
    return distribution;
  }
}

// Usage
const sceneManager = new SceneManager();

const forestScene: SceneConfig = {
  id: 'forest-environment',
  layers: [
    // ... layer configurations
  ]
};

sceneManager.loadScene(forestScene).then(scene => {
  const metrics = sceneManager.getSceneMetrics('forest-environment');
  console.log('Scene metrics:', metrics);
});
```

## 🔍 Implementation Details

### Layer Processing Pipeline

#### Validation Phase

```typescript
export class LayerValidator {
  static validateConfig(config: unknown): ValidationResult<LayerConfig> {
    const errors: ValidationError[] = [];
    
    // Type validation
    if (!isObject(config)) {
      errors.push({ path: 'root', message: 'Configuration must be an object' });
      return { success: false, errors };
    }
    
    // Required field validation
    if (!config.id || typeof config.id !== 'string') {
      errors.push({ path: 'id', message: 'ID is required and must be a string' });
    }
    
    if (!config.type || !isValidLayerType(config.type)) {
      errors.push({ path: 'type', message: 'Type is required and must be a valid LayerType' });
    }
    
    // Position validation
    if (config.position && !isValidVector3(config.position)) {
      errors.push({ path: 'position', message: 'Position must be a valid Vector3' });
    }
    
    // Properties validation
    if (config.properties && !isObject(config.properties)) {
      errors.push({ path: 'properties', message: 'Properties must be an object' });
    }
    
    if (errors.length > 0) {
      return { success: false, errors };
    }
    
    return { success: true, data: config as LayerConfig };
  }
  
  private static isValidVector3(vector: any): vector is Vector3 {
    return isObject(vector) &&
           typeof vector.x === 'number' &&
           typeof vector.y === 'number' &&
           typeof vector.z === 'number';
  }
  
  private static isValidLayerType(type: any): type is LayerType {
    const validTypes: LayerType[] = ['mesh', 'light', 'camera', 'group', 'effect', 'ui', 'animation'];
    return validTypes.includes(type);
  }
}
```

#### Processing Phase

```typescript
export class LayerProcessor {
  async process(configs: LayerConfig[], context: ProcessingContext): Promise<ProcessingResult> {
    const processedLayers: ProcessedLayer[] = [];
    const startTime = performance.now();
    
    for (const config of configs) {
      const processed = await this.processLayer(config, context);
      processedLayers.push(processed);
    }
    
    const endTime = performance.now();
    
    return {
      success: true,
      data: processedLayers,
      time: endTime - startTime
    };
  }
  
  private async processLayer(config: LayerConfig, context: ProcessingContext): Promise<ProcessedLayer> {
    // Apply default values
    const processedConfig = this.applyDefaults(config);
    
    // Resolve asset references
    const resolvedAssets = await this.resolveAssets(processedConfig, context);
    
    // Calculate derived properties
    const derivedProperties = this.calculateDerivedProperties(processedConfig, context);
    
    return {
      ...processedConfig,
      assets: resolvedAssets,
      derived: derivedProperties,
      processingTime: performance.now()
    };
  }
  
  private applyDefaults(config: LayerConfig): LayerConfig {
    return {
      position: { x: 0, y: 0, z: 0 },
      properties: {},
      visible: true,
      zIndex: 0,
      ...config
    };
  }
  
  private async resolveAssets(config: LayerConfig, context: ProcessingContext): Promise<AssetMap> {
    const assets: AssetMap = {};
    
    if (config.properties?.texture) {
      assets.texture = await AssetLoader.load(config.properties.texture, context);
    }
    
    if (config.properties?.material?.map) {
      assets.materialMap = await AssetLoader.load(config.properties.material.map, context);
    }
    
    return assets;
  }
}
```

### Performance Optimization

#### Change Detection System

```typescript
export class LayerChangeDetector {
  private layerStates: Map<string, LayerState> = new Map();
  private changeListeners: Map<string, ChangeCallback[]> = new Map();
  
  trackLayer(layer: Layer): void {
    const currentState = this.captureState(layer);
    this.layerStates.set(layer.id, currentState);
  }
  
  checkForChanges(layer: Layer): ChangeResult {
    const previousState = this.layerStates.get(layer.id);
    const currentState = this.captureState(layer);
    
    if (!previousState) {
      this.layerStates.set(layer.id, currentState);
      return { hasChanges: true, changes: ['initial'] };
    }
    
    const changes = this.detectChanges(previousState, currentState);
    
    if (changes.length > 0) {
      this.layerStates.set(layer.id, currentState);
      this.notifyListeners(layer.id, changes);
    }
    
    return { hasChanges: changes.length > 0, changes };
  }
  
  private captureState(layer: Layer): LayerState {
    return {
      position: { ...layer.position },
      properties: JSON.parse(JSON.stringify(layer.properties)),
      visible: layer.visible,
      zIndex: layer.zIndex,
      lastUpdate: Date.now()
    };
  }
  
  private detectChanges(previous: LayerState, current: LayerState): string[] {
    const changes: string[] = [];
    
    if (!this.isEqual(previous.position, current.position)) {
      changes.push('position');
    }
    
    if (!this.isEqual(previous.properties, current.properties)) {
      changes.push('properties');
    }
    
    if (previous.visible !== current.visible) {
      changes.push('visibility');
    }
    
    if (previous.zIndex !== current.zIndex) {
      changes.push('zIndex');
    }
    
    return changes;
  }
}
```

## ⚡ Performance Characteristics

### Computational Complexity
- **Layer Lookup**: O(1) using Map-based storage
- **Validation**: O(n) where n = number of properties to validate
- **Processing**: O(n*m) where n = layers, m = processing steps per layer
- **Change Detection**: O(1) with cached state comparison

### Memory Optimization

```typescript
// Object pooling for frequent layer operations
export class LayerObjectPool {
  private layerPool: Layer[] = [];
  private configPool: LayerConfig[] = [];
  private vectorPool: Vector3[] = [];
  
  acquireLayer(): Layer {
    return this.layerPool.pop() || new Layer();
  }
  
  releaseLayer(layer: Layer): void {
    layer.reset();
    this.layerPool.push(layer);
  }
  
  acquireVector3(): Vector3 {
    return this.vectorPool.pop() || { x: 0, y: 0, z: 0 };
  }
  
  releaseVector3(vector: Vector3): void {
    vector.x = 0;
    vector.y = 0;
    vector.z = 0;
    this.vectorPool.push(vector);
  }
}

// Usage with pooling
export class OptimizedLayerEngine extends LayerEngine {
  private pool = new LayerObjectPool();
  
  protected createLayer(config: LayerConfig): Layer {
    const layer = this.pool.acquireLayer();
    layer.initialize(config);
    return layer;
  }
  
  protected destroyLayer(layer: Layer): void {
    this.pool.releaseLayer(layer);
  }
}
```

### Performance Monitoring

```typescript
export class LayerPerformanceMonitor {
  private metrics: PerformanceMetrics = {
    layerCount: 0,
    validationTime: 0,
    processingTime: 0,
    memoryUsage: 0,
    cacheHitRatio: 0
  };
  
  startOperation(operation: string): PerformanceToken {
    return {
      operation,
      startTime: performance.now(),
      startMemory: performance.memory?.usedJSHeapSize || 0
    };
  }
  
  endOperation(token: PerformanceToken): void {
    const endTime = performance.now();
    const endMemory = performance.memory?.usedJSHeapSize || 0;
    
    const duration = endTime - token.startTime;
    const memoryDelta = endMemory - token.startMemory;
    
    this.recordMetric(token.operation, {
      duration,
      memoryDelta,
      timestamp: endTime
    });
  }
  
  getMetrics(): PerformanceMetrics {
    return { ...this.metrics };
  }
}
```

---

The Layer System provides a robust foundation for data processing with strong performance characteristics and comprehensive validation, enabling reliable operation of higher-level rendering systems.