# React Integration API - UI Framework Coordination

> Complete React integration patterns for multi-system engine coordination and lifecycle management

## 📋 Overview

The React Integration API provides comprehensive patterns for integrating the Layer, Logic, and Stages systems within React applications. This system handles engine lifecycle management, state synchronization, component composition, and performance monitoring through modern React patterns including hooks, context providers, and optimized rendering strategies.

**Key Files**: `useLayerEngine.ts`, `LauncherScreen.tsx`, `EngineCanvas.tsx`, `ControlPanel.tsx`, `StatusDisplay.tsx`  
**Dependencies**: React 18+, Layer System, Logic System, Stages System  
**Integration**: Orchestrates all engine systems with React lifecycle

## 🔧 Core API

### useLayerEngine Hook

```typescript
export interface LayerEngineOptions {
  /** Initial engine configuration */
  config: SystemConfig;
  
  /** Performance monitoring settings */
  monitoring?: {
    enableFPSTracking: boolean;
    enableMemoryTracking: boolean;
    updateInterval: number;
  };
  
  /** Auto-start engine on initialization */
  autoStart?: boolean;
  
  /** Quality settings */
  quality?: QualitySettings;
  
  /** Event callbacks */
  onInitialized?: (engine: MultiSystemEngine) => void;
  onPerformanceChange?: (metrics: PerformanceMetrics) => void;
  onError?: (error: Error) => void;
}

export interface LayerEngineState {
  /** Multi-system engine instance */
  engine: MultiSystemEngine | null;
  
  /** Engine running state */
  isRunning: boolean;
  
  /** Current performance metrics */
  metrics: PerformanceMetrics;
  
  /** Engine initialization state */
  isInitialized: boolean;
  
  /** Any initialization or runtime errors */
  error: Error | null;
}

export function useLayerEngine(options: LayerEngineOptions): LayerEngineState {
  const [engine, setEngine] = useState<MultiSystemEngine | null>(null);
  const [isRunning, setIsRunning] = useState(false);
  const [metrics, setMetrics] = useState<PerformanceMetrics>({
    fps: 0,
    frameTime: 0,
    memoryUsage: 0,
    layerCount: 0,
    behaviorCount: 0,
    objectCount: 0
  });
  const [isInitialized, setIsInitialized] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  // Initialize engine
  useEffect(() => {
    let mounted = true;
    
    async function initializeEngine() {
      try {
        const newEngine = new MultiSystemEngine(options.config, options.quality);
        
        // Setup performance monitoring
        if (options.monitoring?.enableFPSTracking) {
          newEngine.onPerformanceUpdate((newMetrics) => {
            if (mounted) {
              setMetrics(newMetrics);
              options.onPerformanceChange?.(newMetrics);
            }
          });
        }
        
        // Setup error handling
        newEngine.onError((err) => {
          if (mounted) {
            setError(err);
            options.onError?.(err);
          }
        });
        
        await newEngine.initialize();
        
        if (mounted) {
          setEngine(newEngine);
          setIsInitialized(true);
          options.onInitialized?.(newEngine);
          
          if (options.autoStart !== false) {
            newEngine.start();
            setIsRunning(true);
          }
        }
      } catch (err) {
        if (mounted) {
          setError(err as Error);
        }
      }
    }
    
    initializeEngine();
    
    return () => {
      mounted = false;
      if (engine) {
        engine.dispose();
      }
    };
  }, [options.config]);
  
  return {
    engine,
    isRunning,
    metrics,
    isInitialized,
    error
  };
}
```

### MultiSystemEngine Interface

```typescript
export class MultiSystemEngine {
  private layerEngine: LayerEngine;
  private logicEngine: LogicEngine;
  private stagesEngine: StagesEngine;
  private coordinator: SystemCoordinator;
  private performanceMonitor: PerformanceMonitor;
  
  constructor(config: SystemConfig, quality?: QualitySettings) {
    this.initializeSystems(config, quality);
    this.setupSystemCoordination();
    this.setupPerformanceMonitoring();
  }
  
  /**
   * Initialize all engine systems
   */
  public async initialize(): Promise<void> {
    await Promise.all([
      this.layerEngine.initialize(),
      this.logicEngine.initialize(),
      this.stagesEngine.initialize()
    ]);
    
    this.coordinator.connect();
    this.emitEvent('engine:initialized');
  }
  
  /**
   * Start all engine systems
   */
  public start(): void {
    this.layerEngine.start();
    this.logicEngine.start();
    this.stagesEngine.start();
    this.coordinator.start();
    this.performanceMonitor.start();
    
    this.emitEvent('engine:started');
  }
  
  /**
   * Stop all engine systems
   */
  public stop(): void {
    this.performanceMonitor.stop();
    this.coordinator.stop();
    this.stagesEngine.stop();
    this.logicEngine.stop();
    this.layerEngine.stop();
    
    this.emitEvent('engine:stopped');
  }
  
  /**
   * Update engine configuration
   */
  public updateConfig(updates: Partial<SystemConfig>): void {
    if (updates.layers) {
      this.layerEngine.updateConfig(updates.layers);
    }
    
    if (updates.logic) {
      this.logicEngine.updateConfig(updates.logic);
    }
    
    if (updates.stages) {
      this.stagesEngine.updateConfig(updates.stages);
    }
    
    this.emitEvent('config:updated', updates);
  }
  
  /**
   * Get current performance metrics
   */
  public getMetrics(): PerformanceMetrics {
    return this.performanceMonitor.getMetrics();
  }
  
  /**
   * Dispose all resources
   */
  public dispose(): void {
    this.stop();
    this.coordinator.dispose();
    this.stagesEngine.dispose();
    this.logicEngine.dispose();
    this.layerEngine.dispose();
  }
}
```

### React Component Interfaces

```typescript
export interface EngineCanvasProps {
  /** Engine instance to render */
  engine: MultiSystemEngine;
  
  /** Canvas styling */
  className?: string;
  style?: React.CSSProperties;
  
  /** Canvas event handlers */
  onMouseMove?: (event: React.MouseEvent) => void;
  onMouseClick?: (event: React.MouseEvent) => void;
  onKeyDown?: (event: React.KeyboardEvent) => void;
  
  /** Resize handling */
  autoResize?: boolean;
  width?: number;
  height?: number;
  
  /** Rendering backend selection */
  backend?: 'stages' | 'logic' | 'auto';
}

export interface ControlPanelProps {
  /** Engine instance to control */
  engine: MultiSystemEngine;
  
  /** Available controls */
  controls?: {
    playPause?: boolean;
    reset?: boolean;
    quality?: boolean;
    performance?: boolean;
  };
  
  /** Control callbacks */
  onControlChange?: (control: string, value: any) => void;
  
  /** Panel layout */
  layout?: 'horizontal' | 'vertical' | 'grid';
  compact?: boolean;
}

export interface StatusDisplayProps {
  /** Engine instance to monitor */
  engine: MultiSystemEngine;
  
  /** Metrics to display */
  metrics?: {
    fps?: boolean;
    memory?: boolean;
    objects?: boolean;
    performance?: boolean;
  };
  
  /** Update frequency in milliseconds */
  updateInterval?: number;
  
  /** Display format */
  format?: 'compact' | 'detailed' | 'debug';
}
```

## 💻 Usage Examples

### Basic React Application Setup

```tsx
import React from 'react';
import { useLayerEngine } from './useLayerEngine';
import { EngineCanvas } from './EngineCanvas';
import { ControlPanel } from './ControlPanel';
import { StatusDisplay } from './StatusDisplay';

// Complete React application with engine integration
export function MultiSystemApp() {
  const engineConfig: SystemConfig = {
    layers: {
      validation: true,
      caching: true,
      batchSize: 50
    },
    logic: {
      updateFrequency: 60,
      enablePhysics: true,
      enableAnimations: true,
      behaviorDefaults: {
        animation: { easing: 'easeInOut', duration: 1000 },
        interaction: { debounce: 100 }
      }
    },
    stages: {
      quality: {
        antialias: true,
        shadowMapSize: 2048,
        precision: 'highp',
        enablePostProcessing: true
      },
      performance: {
        targetFPS: 60,
        adaptiveQuality: true
      }
    }
  };
  
  const { engine, isRunning, metrics, isInitialized, error } = useLayerEngine({
    config: engineConfig,
    autoStart: true,
    monitoring: {
      enableFPSTracking: true,
      enableMemoryTracking: true,
      updateInterval: 1000
    },
    onInitialized: (engine) => {
      console.log('Engine initialized successfully');
    },
    onPerformanceChange: (metrics) => {
      if (metrics.fps < 30) {
        console.warn(`Low FPS detected: ${metrics.fps.toFixed(1)}`);
      }
    },
    onError: (error) => {
      console.error('Engine error:', error);
    }
  });
  
  if (error) {
    return (
      <div className="error-container">
        <h2>Engine Error</h2>
        <p>{error.message}</p>
        <button onClick={() => window.location.reload()}>
          Reload Application
        </button>
      </div>
    );
  }
  
  if (!isInitialized || !engine) {
    return (
      <div className="loading-container">
        <div className="loading-spinner" />
        <p>Initializing Engine Systems...</p>
      </div>
    );
  }
  
  return (
    <div className="multi-system-app">
      <header className="app-header">
        <h1>Multi-System Rendering Engine</h1>
        <div className="status-indicator">
          <span className={`status-dot ${isRunning ? 'running' : 'stopped'}`} />
          {isRunning ? 'Running' : 'Stopped'}
        </div>
      </header>
      
      <main className="app-main">
        <div className="render-area">
          <EngineCanvas 
            engine={engine}
            autoResize={true}
            backend="auto"
            className="main-canvas"
            onMouseMove={(e) => console.log('Mouse:', e.clientX, e.clientY)}
          />
        </div>
        
        <aside className="control-sidebar">
          <ControlPanel 
            engine={engine}
            controls={{
              playPause: true,
              reset: true,
              quality: true,
              performance: true
            }}
            layout="vertical"
            onControlChange={(control, value) => {
              console.log(`Control changed: ${control} = ${value}`);
            }}
          />
          
          <StatusDisplay 
            engine={engine}
            metrics={{
              fps: true,
              memory: true,
              objects: true,
              performance: true
            }}
            updateInterval={500}
            format="detailed"
          />
        </aside>
      </main>
      
      <footer className="app-footer">
        <div className="performance-summary">
          FPS: {metrics.fps.toFixed(1)} | 
          Objects: {metrics.objectCount} | 
          Memory: {(metrics.memoryUsage / 1024 / 1024).toFixed(1)}MB
        </div>
      </footer>
    </div>
  );
}

export default MultiSystemApp;
```

### Advanced Hook Integration

```tsx
import React, { useState, useCallback, useMemo } from 'react';

// Advanced engine management with custom hooks
export function useEngineControls(engine: MultiSystemEngine | null) {
  const [isPaused, setIsPaused] = useState(false);
  const [qualityLevel, setQualityLevel] = useState<'low' | 'medium' | 'high'>('high');
  
  const togglePause = useCallback(() => {
    if (!engine) return;
    
    if (isPaused) {
      engine.start();
    } else {
      engine.stop();
    }
    setIsPaused(!isPaused);
  }, [engine, isPaused]);
  
  const resetEngine = useCallback(() => {
    if (!engine) return;
    
    engine.reset();
    console.log('Engine reset completed');
  }, [engine]);
  
  const changeQuality = useCallback((level: 'low' | 'medium' | 'high') => {
    if (!engine) return;
    
    const qualitySettings = {
      low: { antialias: false, shadowMapSize: 512, precision: 'lowp' as const },
      medium: { antialias: true, shadowMapSize: 1024, precision: 'mediump' as const },
      high: { antialias: true, shadowMapSize: 2048, precision: 'highp' as const }
    };
    
    engine.updateQuality(qualitySettings[level]);
    setQualityLevel(level);
  }, [engine]);
  
  return {
    isPaused,
    qualityLevel,
    togglePause,
    resetEngine,
    changeQuality
  };
}

// Performance monitoring hook
export function usePerformanceMonitoring(engine: MultiSystemEngine | null, interval: number = 1000) {
  const [performanceHistory, setPerformanceHistory] = useState<PerformanceMetrics[]>([]);
  const [alerts, setAlerts] = useState<PerformanceAlert[]>([]);
  
  useEffect(() => {
    if (!engine) return;
    
    const updatePerformance = () => {
      const metrics = engine.getMetrics();
      
      setPerformanceHistory(prev => {
        const newHistory = [...prev, metrics].slice(-60); // Keep last 60 measurements
        
        // Check for performance issues
        const avgFPS = newHistory.slice(-10).reduce((sum, m) => sum + m.fps, 0) / 10;
        if (avgFPS < 30) {
          setAlerts(prev => [...prev, {
            type: 'fps',
            message: `Low FPS: ${avgFPS.toFixed(1)}`,
            timestamp: Date.now()
          }]);
        }
        
        return newHistory;
      });
    };
    
    const intervalId = setInterval(updatePerformance, interval);
    return () => clearInterval(intervalId);
  }, [engine, interval]);
  
  const averageMetrics = useMemo(() => {
    if (performanceHistory.length === 0) return null;
    
    const avg = performanceHistory.reduce((acc, metrics) => ({
      fps: acc.fps + metrics.fps,
      frameTime: acc.frameTime + metrics.frameTime,
      memoryUsage: acc.memoryUsage + metrics.memoryUsage,
      layerCount: acc.layerCount + metrics.layerCount,
      behaviorCount: acc.behaviorCount + metrics.behaviorCount,
      objectCount: acc.objectCount + metrics.objectCount
    }), { fps: 0, frameTime: 0, memoryUsage: 0, layerCount: 0, behaviorCount: 0, objectCount: 0 });
    
    const count = performanceHistory.length;
    return {
      fps: avg.fps / count,
      frameTime: avg.frameTime / count,
      memoryUsage: avg.memoryUsage / count,
      layerCount: avg.layerCount / count,
      behaviorCount: avg.behaviorCount / count,
      objectCount: avg.objectCount / count
    };
  }, [performanceHistory]);
  
  return {
    performanceHistory,
    averageMetrics,
    alerts,
    clearAlerts: () => setAlerts([])
  };
}

// Usage in component
export function AdvancedEngineApp() {
  const { engine, isRunning, metrics } = useLayerEngine({
    config: defaultConfig,
    autoStart: true
  });
  
  const controls = useEngineControls(engine);
  const performance = usePerformanceMonitoring(engine, 500);
  
  return (
    <div className="advanced-engine-app">
      <div className="engine-controls">
        <button onClick={controls.togglePause}>
          {controls.isPaused ? 'Resume' : 'Pause'}
        </button>
        <button onClick={controls.resetEngine}>Reset</button>
        
        <select 
          value={controls.qualityLevel} 
          onChange={(e) => controls.changeQuality(e.target.value as any)}
        >
          <option value="low">Low Quality</option>
          <option value="medium">Medium Quality</option>
          <option value="high">High Quality</option>
        </select>
      </div>
      
      <div className="performance-dashboard">
        <h3>Performance Metrics</h3>
        {performance.averageMetrics && (
          <div className="metrics-grid">
            <div>Avg FPS: {performance.averageMetrics.fps.toFixed(1)}</div>
            <div>Avg Frame Time: {performance.averageMetrics.frameTime.toFixed(2)}ms</div>
            <div>Memory Usage: {(performance.averageMetrics.memoryUsage / 1024 / 1024).toFixed(1)}MB</div>
          </div>
        )}
        
        {performance.alerts.length > 0 && (
          <div className="performance-alerts">
            <h4>Performance Alerts</h4>
            {performance.alerts.slice(-5).map((alert, index) => (
              <div key={index} className={`alert alert-${alert.type}`}>
                {alert.message}
              </div>
            ))}
            <button onClick={performance.clearAlerts}>Clear Alerts</button>
          </div>
        )}
      </div>
      
      <EngineCanvas engine={engine} />
    </div>
  );
}
```

### Context Provider Pattern

```tsx
import React, { createContext, useContext, ReactNode } from 'react';

// Engine context for deep component tree integration
interface EngineContextValue {
  engine: MultiSystemEngine | null;
  isRunning: boolean;
  metrics: PerformanceMetrics;
  controls: {
    start: () => void;
    stop: () => void;
    reset: () => void;
    updateConfig: (config: Partial<SystemConfig>) => void;
  };
}

const EngineContext = createContext<EngineContextValue | null>(null);

export function EngineProvider({ 
  children, 
  config 
}: { 
  children: ReactNode; 
  config: SystemConfig;
}) {
  const { engine, isRunning, metrics } = useLayerEngine({
    config,
    autoStart: true,
    monitoring: {
      enableFPSTracking: true,
      enableMemoryTracking: true,
      updateInterval: 1000
    }
  });
  
  const controls = useMemo(() => ({
    start: () => engine?.start(),
    stop: () => engine?.stop(),
    reset: () => engine?.reset(),
    updateConfig: (updates: Partial<SystemConfig>) => engine?.updateConfig(updates)
  }), [engine]);
  
  const value: EngineContextValue = {
    engine,
    isRunning,
    metrics,
    controls
  };
  
  return (
    <EngineContext.Provider value={value}>
      {children}
    </EngineContext.Provider>
  );
}

export function useEngine(): EngineContextValue {
  const context = useContext(EngineContext);
  if (!context) {
    throw new Error('useEngine must be used within an EngineProvider');
  }
  return context;
}

// Component using context
export function EngineStatus() {
  const { isRunning, metrics } = useEngine();
  
  return (
    <div className="engine-status">
      <div className={`status-indicator ${isRunning ? 'running' : 'stopped'}`}>
        {isRunning ? 'Running' : 'Stopped'}
      </div>
      <div className="metrics">
        <span>FPS: {metrics.fps.toFixed(1)}</span>
        <span>Objects: {metrics.objectCount}</span>
      </div>
    </div>
  );
}

// Control component using context
export function EngineControls() {
  const { controls, isRunning } = useEngine();
  
  return (
    <div className="engine-controls">
      <button onClick={isRunning ? controls.stop : controls.start}>
        {isRunning ? 'Stop' : 'Start'}
      </button>
      <button onClick={controls.reset}>Reset</button>
    </div>
  );
}

// Main app with context
export function ContextApp() {
  return (
    <EngineProvider config={defaultConfig}>
      <div className="app">
        <header>
          <h1>Multi-System Engine</h1>
          <EngineStatus />
        </header>
        
        <main>
          <EngineCanvasWithContext />
          <EngineControls />
        </main>
      </div>
    </EngineProvider>
  );
}

function EngineCanvasWithContext() {
  const { engine } = useEngine();
  
  if (!engine) {
    return <div>Loading engine...</div>;
  }
  
  return <EngineCanvas engine={engine} />;
}
```

### Component Composition Patterns

```tsx
// Composable engine components
export function EngineWorkspace({ 
  config, 
  layout = 'default',
  children 
}: { 
  config: SystemConfig;
  layout?: 'default' | 'fullscreen' | 'split';
  children?: ReactNode;
}) {
  const { engine, isRunning, metrics, error } = useLayerEngine({
    config,
    autoStart: true
  });
  
  if (error) {
    return <EngineErrorBoundary error={error} />;
  }
  
  if (!engine) {
    return <EngineLoadingScreen />;
  }
  
  const layoutClass = `engine-workspace layout-${layout}`;
  
  return (
    <div className={layoutClass}>
      <EngineCanvas 
        engine={engine}
        className="main-canvas"
        autoResize={true}
      />
      
      <div className="workspace-overlay">
        {children}
      </div>
      
      <EngineMetricsOverlay 
        metrics={metrics}
        isRunning={isRunning}
      />
    </div>
  );
}

// Specialized components
export function EngineLoadingScreen() {
  return (
    <div className="engine-loading">
      <div className="loading-animation">
        <div className="spinner" />
      </div>
      <h2>Initializing Engine Systems</h2>
      <div className="loading-steps">
        <div className="step completed">✓ Layer System</div>
        <div className="step completed">✓ Logic System</div>
        <div className="step loading">⟳ Stages System</div>
        <div className="step pending">○ Integration</div>
      </div>
    </div>
  );
}

export function EngineErrorBoundary({ error }: { error: Error }) {
  const [showDetails, setShowDetails] = useState(false);
  
  return (
    <div className="engine-error">
      <div className="error-icon">⚠️</div>
      <h2>Engine Initialization Failed</h2>
      <p>{error.message}</p>
      
      <div className="error-actions">
        <button onClick={() => window.location.reload()}>
          Reload Application
        </button>
        <button onClick={() => setShowDetails(!showDetails)}>
          {showDetails ? 'Hide' : 'Show'} Details
        </button>
      </div>
      
      {showDetails && (
        <details className="error-details">
          <summary>Error Stack Trace</summary>
          <pre>{error.stack}</pre>
        </details>
      )}
    </div>
  );
}

export function EngineMetricsOverlay({ 
  metrics, 
  isRunning 
}: { 
  metrics: PerformanceMetrics;
  isRunning: boolean;
}) {
  const [isVisible, setIsVisible] = useState(true);
  
  if (!isVisible) {
    return (
      <button 
        className="metrics-toggle collapsed"
        onClick={() => setIsVisible(true)}
      >
        📊
      </button>
    );
  }
  
  return (
    <div className="metrics-overlay">
      <div className="metrics-header">
        <span>Performance Metrics</span>
        <button onClick={() => setIsVisible(false)}>×</button>
      </div>
      
      <div className="metrics-content">
        <div className="metric">
          <label>Status:</label>
          <span className={isRunning ? 'running' : 'stopped'}>
            {isRunning ? 'Running' : 'Stopped'}
          </span>
        </div>
        
        <div className="metric">
          <label>FPS:</label>
          <span className={metrics.fps < 30 ? 'warning' : 'normal'}>
            {metrics.fps.toFixed(1)}
          </span>
        </div>
        
        <div className="metric">
          <label>Frame Time:</label>
          <span>{metrics.frameTime.toFixed(2)}ms</span>
        </div>
        
        <div className="metric">
          <label>Objects:</label>
          <span>{metrics.objectCount}</span>
        </div>
        
        <div className="metric">
          <label>Memory:</label>
          <span>{(metrics.memoryUsage / 1024 / 1024).toFixed(1)}MB</span>
        </div>
      </div>
    </div>
  );
}

// Usage with composition
export function GameApp() {
  const gameConfig: SystemConfig = {
    // ... game-specific configuration
  };
  
  return (
    <EngineWorkspace config={gameConfig} layout="fullscreen">
      <div className="game-ui">
        <div className="game-hud">
          <div className="score">Score: 1234</div>
          <div className="health">Health: 100%</div>
        </div>
        
        <div className="game-controls">
          <button>Pause</button>
          <button>Settings</button>
        </div>
      </div>
    </EngineWorkspace>
  );
}

export function VisualizationApp() {
  const vizConfig: SystemConfig = {
    // ... visualization-specific configuration
  };
  
  return (
    <EngineWorkspace config={vizConfig} layout="split">
      <div className="visualization-controls">
        <h3>Data Visualization Controls</h3>
        <input type="range" min="0" max="100" />
        <select>
          <option>Bar Chart</option>
          <option>Line Graph</option>
          <option>3D Surface</option>
        </select>
      </div>
    </EngineWorkspace>
  );
}
```

## 🔍 Implementation Details

### Engine Lifecycle Management

#### Initialization Sequence

```typescript
export class EngineLifecycleManager {
  private initializationSteps: InitializationStep[] = [
    { name: 'Layer System', handler: this.initializeLayerSystem.bind(this) },
    { name: 'Logic System', handler: this.initializeLogicSystem.bind(this) },
    { name: 'Stages System', handler: this.initializeStagesSystem.bind(this) },
    { name: 'System Coordination', handler: this.initializeCoordination.bind(this) },
    { name: 'Performance Monitoring', handler: this.initializeMonitoring.bind(this) }
  ];
  
  public async initialize(
    config: SystemConfig,
    onProgress?: (step: string, progress: number) => void
  ): Promise<MultiSystemEngine> {
    const totalSteps = this.initializationSteps.length;
    
    for (let i = 0; i < totalSteps; i++) {
      const step = this.initializationSteps[i];
      onProgress?.(step.name, (i / totalSteps) * 100);
      
      try {
        await step.handler(config);
      } catch (error) {
        throw new Error(`Failed to initialize ${step.name}: ${error.message}`);
      }
    }
    
    onProgress?.('Complete', 100);
    return this.createEngine();
  }
  
  private async initializeLayerSystem(config: SystemConfig): Promise<void> {
    this.layerEngine = new LayerEngine(config.layers);
    await this.layerEngine.initialize();
    
    // Validate layer system
    const healthCheck = this.layerEngine.performHealthCheck();
    if (!healthCheck.healthy) {
      throw new Error(`Layer system health check failed: ${healthCheck.issues.join(', ')}`);
    }
  }
  
  private async initializeLogicSystem(config: SystemConfig): Promise<void> {
    this.logicEngine = new LogicEngine(config.logic);
    await this.logicEngine.initialize();
    
    // Setup behavior validation
    this.logicEngine.enableBehaviorValidation(true);
  }
  
  private async initializeStagesSystem(config: SystemConfig): Promise<void> {
    this.stagesEngine = new StagesEngine(config.stages.quality);
    await this.stagesEngine.initialize();
    
    // Check WebGL capabilities
    const capabilities = this.stagesEngine.getCapabilities();
    if (!capabilities.webgl) {
      console.warn('WebGL not available, falling back to software rendering');
    }
  }
  
  private async initializeCoordination(config: SystemConfig): Promise<void> {
    this.coordinator = new SystemCoordinator(
      this.layerEngine,
      this.logicEngine,
      this.stagesEngine
    );
    
    this.coordinator.setupEventPipeline();
    this.coordinator.validateSystemIntegration();
  }
  
  private async initializeMonitoring(config: SystemConfig): Promise<void> {
    this.performanceMonitor = new PerformanceMonitor({
      targetFPS: config.stages.performance?.targetFPS || 60,
      enableProfiling: config.stages.performance?.enableProfiling || false
    });
    
    this.performanceMonitor.attachToSystems([
      this.layerEngine,
      this.logicEngine,
      this.stagesEngine
    ]);
  }
}
```

#### Error Handling and Recovery

```typescript
export class EngineErrorHandler {
  private errorHistory: EngineError[] = [];
  private recoveryStrategies: Map<string, RecoveryStrategy> = new Map();
  
  constructor() {
    this.setupRecoveryStrategies();
  }
  
  private setupRecoveryStrategies(): void {
    this.recoveryStrategies.set('webgl_context_lost', {
      canRecover: true,
      strategy: this.recoverWebGLContext.bind(this)
    });
    
    this.recoveryStrategies.set('memory_pressure', {
      canRecover: true,
      strategy: this.recoverFromMemoryPressure.bind(this)
    });
    
    this.recoveryStrategies.set('performance_degradation', {
      canRecover: true,
      strategy: this.recoverFromPerformanceDegradation.bind(this)
    });
  }
  
  public handleError(error: Error, context: ErrorContext): ErrorRecoveryResult {
    const engineError: EngineError = {
      error,
      context,
      timestamp: Date.now(),
      id: this.generateErrorId()
    };
    
    this.errorHistory.push(engineError);
    
    // Attempt recovery
    const recoveryStrategy = this.recoveryStrategies.get(context.type);
    if (recoveryStrategy && recoveryStrategy.canRecover) {
      try {
        return recoveryStrategy.strategy(engineError);
      } catch (recoveryError) {
        return {
          recovered: false,
          action: 'restart_required',
          message: `Recovery failed: ${recoveryError.message}`
        };
      }
    }
    
    return {
      recovered: false,
      action: 'restart_required',
      message: error.message
    };
  }
  
  private async recoverWebGLContext(error: EngineError): Promise<ErrorRecoveryResult> {
    console.warn('Attempting WebGL context recovery...');
    
    // Force context restoration
    const canvas = document.querySelector('canvas');
    if (canvas) {
      const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
      if (gl && gl.isContextLost()) {
        // Wait for context restoration
        await new Promise(resolve => {
          canvas.addEventListener('webglcontextrestored', resolve, { once: true });
        });
      }
    }
    
    return {
      recovered: true,
      action: 'continue',
      message: 'WebGL context restored successfully'
    };
  }
  
  private async recoverFromMemoryPressure(error: EngineError): Promise<ErrorRecoveryResult> {
    console.warn('Attempting memory pressure recovery...');
    
    // Reduce quality settings
    const engine = error.context.engine as MultiSystemEngine;
    engine.updateQuality({
      antialias: false,
      shadowMapSize: 512,
      precision: 'lowp'
    });
    
    // Clear caches
    engine.clearCaches();
    
    // Force garbage collection if available
    if (window.gc) {
      window.gc();
    }
    
    return {
      recovered: true,
      action: 'continue',
      message: 'Memory pressure reduced, quality settings lowered'
    };
  }
}
```

## ⚡ Performance Characteristics

### React Optimization Patterns

#### Memoization and Optimization

```typescript
// Optimized component patterns
export const OptimizedEngineCanvas = React.memo<EngineCanvasProps>(({ 
  engine, 
  className,
  ...props 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  // Stable callback references
  const handleResize = useCallback(() => {
    if (canvasRef.current && engine) {
      const rect = canvasRef.current.getBoundingClientRect();
      engine.resize(rect.width, rect.height);
    }
  }, [engine]);
  
  // Effect with proper dependencies
  useEffect(() => {
    if (!canvasRef.current || !engine) return;
    
    engine.attachCanvas(canvasRef.current);
    handleResize();
    
    return () => {
      engine.detachCanvas();
    };
  }, [engine, handleResize]);
  
  // Resize observer for responsive behavior
  useEffect(() => {
    if (!canvasRef.current) return;
    
    const resizeObserver = new ResizeObserver(handleResize);
    resizeObserver.observe(canvasRef.current);
    
    return () => {
      resizeObserver.disconnect();
    };
  }, [handleResize]);
  
  return (
    <canvas
      ref={canvasRef}
      className={className}
      {...props}
    />
  );
}, (prevProps, nextProps) => {
  // Custom comparison for engine prop
  return prevProps.engine === nextProps.engine &&
         prevProps.className === nextProps.className;
});
```

#### State Management Optimization

```typescript
// Optimized state management with reducers
interface EngineState {
  isRunning: boolean;
  metrics: PerformanceMetrics;
  quality: QualitySettings;
  errors: Error[];
}

type EngineAction = 
  | { type: 'START' }
  | { type: 'STOP' }
  | { type: 'UPDATE_METRICS'; metrics: PerformanceMetrics }
  | { type: 'UPDATE_QUALITY'; quality: Partial<QualitySettings> }
  | { type: 'ADD_ERROR'; error: Error }
  | { type: 'CLEAR_ERRORS' };

function engineReducer(state: EngineState, action: EngineAction): EngineState {
  switch (action.type) {
    case 'START':
      return { ...state, isRunning: true };
    
    case 'STOP':
      return { ...state, isRunning: false };
    
    case 'UPDATE_METRICS':
      return { ...state, metrics: action.metrics };
    
    case 'UPDATE_QUALITY':
      return { 
        ...state, 
        quality: { ...state.quality, ...action.quality }
      };
    
    case 'ADD_ERROR':
      return { 
        ...state, 
        errors: [...state.errors, action.error].slice(-10) // Keep last 10 errors
      };
    
    case 'CLEAR_ERRORS':
      return { ...state, errors: [] };
    
    default:
      return state;
  }
}

export function useOptimizedEngine(config: SystemConfig) {
  const [state, dispatch] = useReducer(engineReducer, {
    isRunning: false,
    metrics: initialMetrics,
    quality: defaultQuality,
    errors: []
  });
  
  const [engine] = useState(() => new MultiSystemEngine(config));
  
  // Batch state updates
  const batchedDispatch = useBatch(dispatch);
  
  useEffect(() => {
    const unsubscribeMetrics = engine.onMetricsUpdate((metrics) => {
      batchedDispatch({ type: 'UPDATE_METRICS', metrics });
    });
    
    const unsubscribeErrors = engine.onError((error) => {
      batchedDispatch({ type: 'ADD_ERROR', error });
    });
    
    return () => {
      unsubscribeMetrics();
      unsubscribeErrors();
    };
  }, [engine, batchedDispatch]);
  
  return { state, dispatch: batchedDispatch, engine };
}

// Batching utility for reducing re-renders
function useBatch<T>(dispatch: React.Dispatch<T>) {
  const batchedDispatch = useCallback((action: T) => {
    ReactDOM.unstable_batchedUpdates(() => {
      dispatch(action);
    });
  }, [dispatch]);
  
  return batchedDispatch;
}
```

---

The React Integration API provides comprehensive patterns for building sophisticated multi-system applications with optimized performance characteristics and excellent developer experience.