# Logic System API - Behavior & Animation Engine

> Comprehensive behavior processing, animation management, and 2D rendering system

## 📋 Overview

The Logic System provides sophisticated behavior processing and animation capabilities, building upon the Layer System foundation to deliver interactive animations, user input handling, and 2D rendering. This system supports both DOM-based and PIXI.js-based rendering with comprehensive timing control and behavior composition.

**Key Files**: `LogicEngine.ts`, `LogicBehavior.ts`, `LogicAnimation.ts`, `LogicRenderer.tsx`, `LogicTicker.ts`  
**Dependencies**: `LogicTypes.ts`, `LogicConfig.json`, Layer System  
**Integration**: Consumes Layer System data, provides data to Stages System

## 🔧 Core API

### LogicConfig Interface

```typescript
export interface LogicConfig {
  /** Global logic system settings */
  updateFrequency: number;
  
  /** Feature toggles */
  enablePhysics: boolean;
  enableAnimations: boolean;
  enableInteractions: boolean;
  
  /** Behavior configuration defaults */
  behaviorDefaults: BehaviorDefaults;
  
  /** Layer definitions and image registry */
  layersID: string[];
  imageRegistry: Record<string, string>;
  layers: LayerConfig[];
  
  /** Performance settings */
  performance?: {
    targetFPS: number;
    enableProfiling: boolean;
    adaptiveQuality: boolean;
  };
}

export interface BehaviorDefaults {
  animation: {
    easing: EasingFunction;
    duration: number;
  };
  interaction: {
    debounce: number;
  };
  physics: {
    gravity: number;
    friction: number;
  };
}

export type EasingFunction = 'linear' | 'easeIn' | 'easeOut' | 'easeInOut' | 'bounce' | 'elastic';
```

#### Configuration Details

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `updateFrequency` | `number` | `60` | Updates per second for behavior processing |
| `enablePhysics` | `boolean` | `true` | Enable physics simulation behaviors |
| `enableAnimations` | `boolean` | `true` | Enable animation behavior processing |
| `enableInteractions` | `boolean` | `true` | Enable user interaction handling |
| `behaviorDefaults` | `BehaviorDefaults` | - | Default settings for behavior types |
| `layersID` | `string[]` | `[]` | Array of layer identifiers to process |
| `imageRegistry` | `Record<string, string>` | `{}` | Asset URL mapping for layers |
| `layers` | `LayerConfig[]` | `[]` | Layer configuration array |

### LogicEngine Interface

```typescript
export class LogicEngine {
  private behaviors: Map<string, Behavior> = new Map();
  private ticker: LogicTicker;
  private config: LogicConfig;
  
  constructor(config: LogicConfig) {
    this.config = config;
    this.ticker = createRafTicker();
    this.setupUpdateLoop();
  }
  
  /**
   * Add behavior to the engine
   */
  public addBehavior(id: string, behavior: Behavior): void {
    this.behaviors.set(id, behavior);
    behavior.initialize(this.config);
    this.emitEvent('behavior:added', { id, behavior });
  }
  
  /**
   * Update behavior properties
   */
  public updateBehavior(id: string, updates: BehaviorUpdate): boolean {
    const behavior = this.behaviors.get(id);
    if (!behavior) return false;
    
    behavior.update(updates);
    this.emitEvent('behavior:updated', { id, behavior });
    return true;
  }
  
  /**
   * Remove behavior from engine
   */
  public removeBehavior(id: string): boolean {
    const behavior = this.behaviors.get(id);
    if (!behavior) return false;
    
    behavior.dispose();
    this.behaviors.delete(id);
    this.emitEvent('behavior:removed', { id });
    return true;
  }
  
  /**
   * Process all behaviors for frame
   */
  public update(deltaTime: number): void {
    this.behaviors.forEach((behavior, id) => {
      if (behavior.enabled) {
        behavior.update(deltaTime);
      }
    });
    
    this.emitEvent('frame:updated', { deltaTime, behaviorCount: this.behaviors.size });
  }
  
  /**
   * Start engine processing
   */
  public start(): void {
    this.ticker.subscribe((deltaTime) => this.update(deltaTime));
  }
  
  /**
   * Stop engine processing
   */
  public stop(): void {
    this.ticker.unsubscribe();
  }
}
```

### Behavior Interface

```typescript
export interface Behavior {
  /** Unique behavior identifier */
  id: string;
  
  /** Behavior enabled state */
  enabled: boolean;
  
  /** Initialize behavior with configuration */
  initialize(config: LogicConfig): void;
  
  /** Update behavior state with delta time */
  update(deltaTime: number): void;
  
  /** Reset behavior to initial state */
  reset(): void;
  
  /** Clean up behavior resources */
  dispose(): void;
  
  /** Get current behavior state */
  getState(): BehaviorState;
  
  /** Check if behavior has pending changes */
  isDirty(): boolean;
  
  /** Clear dirty flag after processing */
  clearDirty(): void;
}

export abstract class BaseBehavior implements Behavior {
  public id: string;
  public enabled: boolean = true;
  protected isDirtyFlag: boolean = false;
  protected config: LogicConfig;
  
  constructor(id: string) {
    this.id = id;
  }
  
  public initialize(config: LogicConfig): void {
    this.config = config;
    this.onInitialize();
  }
  
  public abstract update(deltaTime: number): void;
  public abstract reset(): void;
  public abstract getState(): BehaviorState;
  
  protected abstract onInitialize(): void;
  
  public dispose(): void {
    this.enabled = false;
    this.onDispose();
  }
  
  protected onDispose(): void {}
  
  public isDirty(): boolean {
    return this.isDirtyFlag;
  }
  
  public clearDirty(): void {
    this.isDirtyFlag = false;
  }
  
  protected markDirty(): void {
    this.isDirtyFlag = true;
  }
}
```

## 🎯 Primary Functions

### LogicEngine.addBehavior()

```typescript
function addBehavior(id: string, behavior: Behavior): void
```

**Primary behavior registration function** - adds behavior to processing engine.

#### Parameters
- **`id`**: Unique identifier for the behavior
- **`behavior`**: Behavior instance implementing the Behavior interface

#### Returns
Void - behavior is registered and will be processed on next update cycle.

### AnimationBehavior.animate()

```typescript
function animate(
  property: string, 
  target: number, 
  duration: number, 
  options?: AnimationOptions
): Animation
```

**Animation creation function** - creates property-based animations with easing.

#### Parameters
- **`property`**: Target property name to animate
- **`target`**: Target value for animation
- **`duration`**: Animation duration in milliseconds
- **`options`**: Optional easing, callbacks, and timing configuration

#### Returns
`Animation` instance with control methods (play, pause, stop, reverse).

### LogicRenderer.render()

```typescript
function render(config: LogicConfig, renderer?: 'pixi' | 'dom'): ReactElement
```

**React rendering function** - creates rendered output from logic configuration.

#### Parameters
- **`config`**: Complete logic configuration with layers and behaviors
- **`renderer`**: Optional backend selection ('pixi' for WebGL, 'dom' for HTML)

#### Returns
React element ready for mounting in application.

## 💻 Usage Examples

### Basic Behavior Creation

```typescript
import { LogicEngine, AnimationBehavior } from './LogicEngine';

// Initialize logic engine
const logicConfig: LogicConfig = {
  updateFrequency: 60,
  enablePhysics: true,
  enableAnimations: true,
  enableInteractions: true,
  behaviorDefaults: {
    animation: { easing: 'easeInOut', duration: 1000 },
    interaction: { debounce: 100 },
    physics: { gravity: 9.81, friction: 0.8 }
  },
  layersID: ['spinning-gear'],
  imageRegistry: {
    'spinning-gear': './assets/gear.png'
  },
  layers: [
    {
      id: 'spinning-gear',
      imageRef: { kind: 'urlId', id: 'spinning-gear' },
      position: { xPct: 50, yPct: 50 },
      scale: { pct: 100 },
      angleDeg: 0
    }
  ]
};

const engine = new LogicEngine(logicConfig);

// Create rotation animation behavior
const rotationBehavior = new AnimationBehavior('gear-rotation');
rotationBehavior.animate('rotation', 360, 2000, {
  easing: 'linear',
  repeat: Infinity,
  direction: 'normal'
});

// Add behavior to engine
engine.addBehavior('gear-rotation', rotationBehavior);

// Start processing
engine.start();
console.log('Logic engine started with rotation behavior');
```

### Advanced Animation Composition

```typescript
import { AnimationBehavior, InteractionBehavior } from './LogicBehavior';

class ComplexAnimationBehavior extends BaseBehavior {
  private animations: Map<string, Animation> = new Map();
  private timeline: Timeline;
  
  protected onInitialize(): void {
    this.timeline = new Timeline();
    this.setupAnimationSequence();
  }
  
  private setupAnimationSequence(): void {
    // Create fade-in animation
    const fadeIn = this.timeline.to(this, {
      opacity: 1,
      duration: 500,
      easing: 'easeOut'
    });
    
    // Chain scale animation
    const scaleUp = this.timeline.to(this, {
      scale: 1.2,
      duration: 300,
      easing: 'bounce',
      delay: 200
    });
    
    // Simultaneous rotation
    const rotate = this.timeline.to(this, {
      rotation: 180,
      duration: 800,
      easing: 'easeInOut'
    }, '-=500'); // Start 500ms before scale ends
    
    // Final position movement
    const move = this.timeline.to(this, {
      x: 100,
      y: 50,
      duration: 600,
      easing: 'elastic'
    });
    
    this.animations.set('fadeIn', fadeIn);
    this.animations.set('scale', scaleUp);
    this.animations.set('rotate', rotate);
    this.animations.set('move', move);
  }
  
  public update(deltaTime: number): void {
    if (!this.enabled) return;
    
    this.timeline.update(deltaTime);
    
    // Check for completion
    if (this.timeline.isComplete()) {
      this.onAnimationComplete();
    }
    
    this.markDirty();
  }
  
  private onAnimationComplete(): void {
    console.log('Complex animation sequence completed');
    this.emitEvent('animation:complete', { behaviorId: this.id });
  }
  
  public getState(): BehaviorState {
    return {
      opacity: this.timeline.getProperty('opacity'),
      scale: this.timeline.getProperty('scale'),
      rotation: this.timeline.getProperty('rotation'),
      x: this.timeline.getProperty('x'),
      y: this.timeline.getProperty('y'),
      progress: this.timeline.getProgress(),
      isPlaying: this.timeline.isPlaying()
    };
  }
  
  public reset(): void {
    this.timeline.restart();
    this.clearDirty();
  }
}

// Usage
const complexBehavior = new ComplexAnimationBehavior('complex-sequence');
engine.addBehavior('complex-sequence', complexBehavior);
```

### Interactive Behavior Implementation

```typescript
class MouseFollowBehavior extends BaseBehavior {
  private targetX: number = 0;
  private targetY: number = 0;
  private currentX: number = 0;
  private currentY: number = 0;
  private smoothing: number = 0.1;
  
  protected onInitialize(): void {
    this.setupMouseTracking();
  }
  
  private setupMouseTracking(): void {
    // Add mouse move listener
    document.addEventListener('mousemove', (event) => {
      this.targetX = event.clientX;
      this.targetY = event.clientY;
      this.markDirty();
    });
  }
  
  public update(deltaTime: number): void {
    if (!this.enabled) return;
    
    // Smooth interpolation to target position
    const deltaX = this.targetX - this.currentX;
    const deltaY = this.targetY - this.currentY;
    
    this.currentX += deltaX * this.smoothing * (deltaTime / 16.67);
    this.currentY += deltaY * this.smoothing * (deltaTime / 16.67);
    
    // Update visual position
    this.updatePosition(this.currentX, this.currentY);
  }
  
  private updatePosition(x: number, y: number): void {
    // Convert screen coordinates to layer coordinates
    const layerX = (x / window.innerWidth) * 100;
    const layerY = (y / window.innerHeight) * 100;
    
    this.emitEvent('position:update', {
      layerId: this.id,
      position: { xPct: layerX, yPct: layerY }
    });
  }
  
  public getState(): BehaviorState {
    return {
      targetX: this.targetX,
      targetY: this.targetY,
      currentX: this.currentX,
      currentY: this.currentY,
      velocity: {
        x: (this.targetX - this.currentX) * this.smoothing,
        y: (this.targetY - this.currentY) * this.smoothing
      }
    };
  }
  
  public reset(): void {
    this.currentX = this.targetX;
    this.currentY = this.targetY;
    this.clearDirty();
  }
}

// Usage with interaction
const mouseBehavior = new MouseFollowBehavior('mouse-follower');
engine.addBehavior('mouse-follower', mouseBehavior);

// Listen for position updates
engine.on('position:update', (data) => {
  console.log(`Layer ${data.layerId} moved to ${data.position.xPct}%, ${data.position.yPct}%`);
});
```

### Physics Simulation Behavior

```typescript
class PhysicsBehavior extends BaseBehavior {
  private position: Vector2 = { x: 0, y: 0 };
  private velocity: Vector2 = { x: 0, y: 0 };
  private acceleration: Vector2 = { x: 0, y: 0 };
  private mass: number = 1;
  private forces: Vector2[] = [];
  
  protected onInitialize(): void {
    this.setupPhysicsWorld();
  }
  
  private setupPhysicsWorld(): void {
    // Add gravity force
    this.addForce({ x: 0, y: this.config.behaviorDefaults.physics.gravity * this.mass });
    
    // Add drag force
    this.addDragForce(this.config.behaviorDefaults.physics.friction);
  }
  
  public addForce(force: Vector2): void {
    this.forces.push(force);
  }
  
  private addDragForce(dragCoefficient: number): void {
    // Drag force opposes velocity
    const dragX = -this.velocity.x * dragCoefficient;
    const dragY = -this.velocity.y * dragCoefficient;
    this.addForce({ x: dragX, y: dragY });
  }
  
  public update(deltaTime: number): void {
    if (!this.enabled) return;
    
    const dt = deltaTime / 1000; // Convert to seconds
    
    // Calculate net force
    const netForce = this.forces.reduce(
      (acc, force) => ({ x: acc.x + force.x, y: acc.y + force.y }),
      { x: 0, y: 0 }
    );
    
    // Apply Newton's second law: F = ma, so a = F/m
    this.acceleration.x = netForce.x / this.mass;
    this.acceleration.y = netForce.y / this.mass;
    
    // Integrate velocity: v = v0 + a*dt
    this.velocity.x += this.acceleration.x * dt;
    this.velocity.y += this.acceleration.y * dt;
    
    // Integrate position: x = x0 + v*dt
    this.position.x += this.velocity.x * dt;
    this.position.y += this.velocity.y * dt;
    
    // Apply boundary constraints
    this.applyBoundaryConstraints();
    
    // Clear forces for next frame
    this.forces = [];
    
    this.markDirty();
  }
  
  private applyBoundaryConstraints(): void {
    const margin = 10;
    
    // Bounce off boundaries
    if (this.position.x < margin) {
      this.position.x = margin;
      this.velocity.x = -this.velocity.x * 0.8; // Energy loss on bounce
    }
    
    if (this.position.x > 100 - margin) {
      this.position.x = 100 - margin;
      this.velocity.x = -this.velocity.x * 0.8;
    }
    
    if (this.position.y < margin) {
      this.position.y = margin;
      this.velocity.y = -this.velocity.y * 0.8;
    }
    
    if (this.position.y > 100 - margin) {
      this.position.y = 100 - margin;
      this.velocity.y = -this.velocity.y * 0.8;
    }
  }
  
  public getState(): BehaviorState {
    return {
      position: { ...this.position },
      velocity: { ...this.velocity },
      acceleration: { ...this.acceleration },
      kineticEnergy: 0.5 * this.mass * (this.velocity.x ** 2 + this.velocity.y ** 2),
      speed: Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2)
    };
  }
  
  public reset(): void {
    this.position = { x: 50, y: 10 }; // Start at top center
    this.velocity = { x: Math.random() * 20 - 10, y: 0 }; // Random horizontal velocity
    this.acceleration = { x: 0, y: 0 };
    this.forces = [];
    this.clearDirty();
  }
}

// Usage with external forces
const physicsBehavior = new PhysicsBehavior('physics-ball');
engine.addBehavior('physics-ball', physicsBehavior);

// Add wind force on user interaction
document.addEventListener('click', (event) => {
  const windForce = {
    x: (event.clientX / window.innerWidth - 0.5) * 50,
    y: (event.clientY / window.innerHeight - 0.5) * 50
  };
  physicsBehavior.addForce(windForce);
});
```

### React Component Integration

```tsx
import React, { useEffect, useRef, useState } from 'react';
import { LogicEngine, LogicConfig } from './LogicEngine';
import { LogicRenderer } from './LogicRenderer';

// Advanced React integration with engine lifecycle
export function LogicSystemApp({ config }: { config: LogicConfig }) {
  const [engine, setEngine] = useState<LogicEngine | null>(null);
  const [isRunning, setIsRunning] = useState(false);
  const [metrics, setMetrics] = useState<EngineMetrics>({
    fps: 0,
    behaviorCount: 0,
    updateTime: 0
  });
  
  // Initialize engine
  useEffect(() => {
    const newEngine = new LogicEngine(config);
    
    // Setup performance monitoring
    newEngine.on('frame:updated', (data) => {
      setMetrics(prev => ({
        fps: 1000 / data.deltaTime,
        behaviorCount: data.behaviorCount,
        updateTime: data.deltaTime
      }));
    });
    
    setEngine(newEngine);
    
    return () => {
      newEngine.stop();
      newEngine.dispose();
    };
  }, [config]);
  
  // Start/stop engine
  useEffect(() => {
    if (!engine) return;
    
    engine.start();
    setIsRunning(true);
    
    return () => {
      engine.stop();
      setIsRunning(false);
    };
  }, [engine]);
  
  if (!engine) {
    return <div>Loading Logic Engine...</div>;
  }
  
  return (
    <div className="logic-system-app">
      <div className="render-area">
        <LogicRenderer config={config} renderer="pixi" />
      </div>
      
      <div className="control-panel">
        <h3>Logic Engine Control</h3>
        <div className="status">
          <div>Status: {isRunning ? 'Running' : 'Stopped'}</div>
          <div>FPS: {metrics.fps.toFixed(1)}</div>
          <div>Behaviors: {metrics.behaviorCount}</div>
          <div>Update Time: {metrics.updateTime.toFixed(2)}ms</div>
        </div>
        
        <div className="controls">
          <button onClick={() => engine.start()}>Start</button>
          <button onClick={() => engine.stop()}>Stop</button>
          <button onClick={() => engine.reset()}>Reset</button>
        </div>
      </div>
      
      <div className="behavior-list">
        <h3>Active Behaviors</h3>
        <BehaviorList engine={engine} />
      </div>
    </div>
  );
}

// Behavior management component
function BehaviorList({ engine }: { engine: LogicEngine }) {
  const [behaviors, setBehaviors] = useState<BehaviorInfo[]>([]);
  
  useEffect(() => {
    const updateBehaviors = () => {
      const behaviorData = engine.getAllBehaviors().map(behavior => ({
        id: behavior.id,
        enabled: behavior.enabled,
        state: behavior.getState(),
        isDirty: behavior.isDirty()
      }));
      setBehaviors(behaviorData);
    };
    
    // Update every 100ms
    const interval = setInterval(updateBehaviors, 100);
    return () => clearInterval(interval);
  }, [engine]);
  
  return (
    <div className="behavior-list">
      {behaviors.map(behavior => (
        <div key={behavior.id} className="behavior-item">
          <div className="behavior-header">
            <span className="behavior-id">{behavior.id}</span>
            <span className={`status ${behavior.enabled ? 'enabled' : 'disabled'}`}>
              {behavior.enabled ? 'Enabled' : 'Disabled'}
            </span>
            {behavior.isDirty && <span className="dirty-indicator">*</span>}
          </div>
          <div className="behavior-state">
            <pre>{JSON.stringify(behavior.state, null, 2)}</pre>
          </div>
          <div className="behavior-controls">
            <button onClick={() => engine.toggleBehavior(behavior.id)}>
              {behavior.enabled ? 'Disable' : 'Enable'}
            </button>
            <button onClick={() => engine.resetBehavior(behavior.id)}>
              Reset
            </button>
          </div>
        </div>
      ))}
    </div>
  );
}
```

## 🔍 Implementation Details

### Timing and Animation System

#### RAF Ticker Implementation

```typescript
export interface RafTicker {
  subscribe: (callback: (deltaTime: number) => void) => () => void;
  unsubscribe: () => void;
  pause: () => void;
  resume: () => void;
  isRunning: () => boolean;
}

export function createRafTicker(): RafTicker {
  const subscribers = new Set<(deltaTime: number) => void>();
  let lastTime = 0;
  let rafId: number | null = null;
  let isPaused = false;
  
  const tick = (currentTime: number) => {
    if (isPaused) {
      rafId = requestAnimationFrame(tick);
      return;
    }
    
    const deltaTime = lastTime === 0 ? 16.67 : currentTime - lastTime;
    lastTime = currentTime;
    
    // Call all subscribers
    subscribers.forEach(callback => {
      try {
        callback(deltaTime);
      } catch (error) {
        console.error('Error in ticker callback:', error);
      }
    });
    
    if (subscribers.size > 0) {
      rafId = requestAnimationFrame(tick);
    } else {
      rafId = null;
    }
  };
  
  return {
    subscribe: (callback: (deltaTime: number) => void) => {
      subscribers.add(callback);
      
      // Start ticker if this is the first subscriber
      if (subscribers.size === 1 && rafId === null) {
        lastTime = 0;
        rafId = requestAnimationFrame(tick);
      }
      
      // Return unsubscribe function
      return () => {
        subscribers.delete(callback);
      };
    },
    
    unsubscribe: () => {
      subscribers.clear();
      if (rafId !== null) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
    },
    
    pause: () => {
      isPaused = true;
    },
    
    resume: () => {
      isPaused = false;
      lastTime = 0; // Reset timing on resume
    },
    
    isRunning: () => {
      return rafId !== null && !isPaused;
    }
  };
}
```

#### Animation Timeline System

```typescript
export class Timeline {
  private animations: TimelineAnimation[] = [];
  private currentTime: number = 0;
  private duration: number = 0;
  private isPlaying: boolean = false;
  
  public to(target: any, properties: AnimationProperties, position?: string | number): Animation {
    const animation = new TimelineAnimation(target, properties);
    
    // Calculate start time based on position
    let startTime = this.duration;
    if (typeof position === 'number') {
      startTime = position;
    } else if (typeof position === 'string') {
      if (position.startsWith('-=')) {
        const offset = parseFloat(position.substring(2));
        startTime = this.duration - offset;
      } else if (position.startsWith('+=')) {
        const offset = parseFloat(position.substring(2));
        startTime = this.duration + offset;
      }
    }
    
    animation.startTime = Math.max(0, startTime);
    animation.endTime = animation.startTime + (properties.duration || 1000);
    
    this.animations.push(animation);
    this.duration = Math.max(this.duration, animation.endTime);
    
    return animation;
  }
  
  public update(deltaTime: number): void {
    if (!this.isPlaying) return;
    
    this.currentTime += deltaTime;
    
    this.animations.forEach(animation => {
      if (this.currentTime >= animation.startTime && this.currentTime <= animation.endTime) {
        const localTime = this.currentTime - animation.startTime;
        const progress = localTime / (animation.endTime - animation.startTime);
        animation.update(progress);
      }
    });
  }
  
  public play(): void {
    this.isPlaying = true;
  }
  
  public pause(): void {
    this.isPlaying = false;
  }
  
  public restart(): void {
    this.currentTime = 0;
    this.isPlaying = true;
    this.animations.forEach(animation => animation.reset());
  }
  
  public getProgress(): number {
    return this.duration > 0 ? this.currentTime / this.duration : 0;
  }
  
  public isComplete(): boolean {
    return this.currentTime >= this.duration;
  }
}

class TimelineAnimation {
  public startTime: number = 0;
  public endTime: number = 0;
  private target: any;
  private properties: AnimationProperties;
  private initialValues: Record<string, number> = {};
  
  constructor(target: any, properties: AnimationProperties) {
    this.target = target;
    this.properties = properties;
    this.captureInitialValues();
  }
  
  private captureInitialValues(): void {
    Object.keys(this.properties).forEach(key => {
      if (key !== 'duration' && key !== 'easing') {
        this.initialValues[key] = this.target[key] || 0;
      }
    });
  }
  
  public update(progress: number): void {
    // Apply easing
    const easedProgress = this.applyEasing(progress, this.properties.easing || 'linear');
    
    // Interpolate properties
    Object.keys(this.properties).forEach(key => {
      if (key !== 'duration' && key !== 'easing') {
        const initial = this.initialValues[key];
        const target = this.properties[key] as number;
        this.target[key] = initial + (target - initial) * easedProgress;
      }
    });
  }
  
  private applyEasing(progress: number, easing: EasingFunction): number {
    switch (easing) {
      case 'linear':
        return progress;
      case 'easeIn':
        return progress * progress;
      case 'easeOut':
        return 1 - (1 - progress) * (1 - progress);
      case 'easeInOut':
        return progress < 0.5 
          ? 2 * progress * progress 
          : 1 - 2 * (1 - progress) * (1 - progress);
      case 'bounce':
        return this.bounceEasing(progress);
      case 'elastic':
        return this.elasticEasing(progress);
      default:
        return progress;
    }
  }
  
  private bounceEasing(t: number): number {
    if (t < 1 / 2.75) {
      return 7.5625 * t * t;
    } else if (t < 2 / 2.75) {
      return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
    } else if (t < 2.5 / 2.75) {
      return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
    } else {
      return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    }
  }
  
  private elasticEasing(t: number): number {
    const c4 = (2 * Math.PI) / 3;
    return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
  }
  
  public reset(): void {
    this.captureInitialValues();
  }
}
```

## ⚡ Performance Characteristics

### Computational Complexity
- **Behavior Processing**: O(n) where n = number of active behaviors
- **Animation Updates**: O(n*m) where n = behaviors, m = animated properties per behavior
- **Event Handling**: O(1) with Map-based lookups
- **Timeline Processing**: O(n) where n = timeline animations

### Optimization Strategies

```typescript
// Behavior pooling for performance
export class BehaviorPool {
  private pools: Map<string, Behavior[]> = new Map();
  
  public acquire<T extends Behavior>(type: string, factory: () => T): T {
    let pool = this.pools.get(type);
    if (!pool) {
      pool = [];
      this.pools.set(type, pool);
    }
    
    const behavior = pool.pop() as T || factory();
    return behavior;
  }
  
  public release(type: string, behavior: Behavior): void {
    behavior.reset();
    behavior.enabled = false;
    
    const pool = this.pools.get(type) || [];
    pool.push(behavior);
    this.pools.set(type, pool);
  }
}

// Batch processing for multiple behaviors
export class BatchProcessor {
  private updateQueue: BehaviorUpdate[] = [];
  
  public queueUpdate(update: BehaviorUpdate): void {
    this.updateQueue.push(update);
  }
  
  public processBatch(): void {
    if (this.updateQueue.length === 0) return;
    
    // Group updates by behavior type for cache efficiency
    const groupedUpdates = this.groupUpdatesByType(this.updateQueue);
    
    groupedUpdates.forEach((updates, type) => {
      this.processBehaviorTypeUpdates(type, updates);
    });
    
    this.updateQueue = [];
  }
  
  private groupUpdatesByType(updates: BehaviorUpdate[]): Map<string, BehaviorUpdate[]> {
    const grouped = new Map<string, BehaviorUpdate[]>();
    
    updates.forEach(update => {
      const type = update.behaviorType;
      if (!grouped.has(type)) {
        grouped.set(type, []);
      }
      grouped.get(type)!.push(update);
    });
    
    return grouped;
  }
}
```

---

The Logic System provides comprehensive behavior processing and animation capabilities with excellent performance characteristics and flexible integration options for 2D rendering applications.